<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第3章 表、栈和队列]]></title>
    <url>%2F%E7%AC%AC3%E7%AB%A0%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[表ADT基本概念​ 空表（empty list）：大小为0的表。 ​ 前驱元、后继元。 链表函数原型 123456789101112struct Node;typedef struct Node *PtrToNode;typedef PtrToNode List;typedef PtrToNode Position;List MakeEmpty(List L);int IsEmpty(List L);int IsLast(Position P, List L);Position Find(int X, List L);void Insert(int X, List L, Position P);void DeleteList(List L);Position Header(List L); 具体实现：略 常见的错误链表一般会出现指针变量包含了伪地址的问题。删除表时，需要一个中间量来储存上一个节点。同时，使用malloc之后记得将该节点初始化。 例子多项式ADT令F(X) = ∑i=0N AiXi。如果多项式的次数过大，使用普通方法的运行时间就难以接受了。于是可以采用多项式ADT来实现多项式的加减乘等操作。 多项式ADT的数组实现的类型声明 12345typedef struct&#123; int CoeffArray[MaxDegree + 1]; int HighPower;&#125; * Polynomial; 将多项式初始化为零的过程 12345678void ZeroPolynomial(Polynomial Poly)&#123; int i; for(i = 0; i &lt;= MaxDegree; i++) Poly-&gt;CoeffArray[i] = 0; Poly-&gt;HighPower = 0;&#125; 两个多项式相加的过程 12345678void AddPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolySum)&#123; int i; ZeroPolynomial(PolySum); PolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower); for(i = PolySum-&gt;HighPower; i &gt;= 0; i--) PolySum-&gt;CoeffArray[i] = Poly1-&gt;CoeffArray[i] + Poly2-&gt;CoeffArray[i];&#125; 两个多项式相乘的过程 12345678910111213void MultPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)&#123; int i, j; ZeroPolynomial(PolyProd); PolySum-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower; if(PolyProd-&gt;HighPower &gt; MaxDegree) Error("Exceeded array size"); else for(i = 0; i &lt;= Poly1-&gt;HighPower; i++) for(j = 0; j &lt;= Poly2-&gt;HighPower; j++) PolyProd-&gt;CoeffArray[i + j] += Poly1-&gt;CoeffArray[i] * Poly2-&gt;CoeffArray[j];&#125; 栈ADT栈模型栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，即顶（top）。对栈的基本操作有Push和Pop。 栈有时又叫LIFO(后进先出)表。 栈的实现链表实现栈ADT链表实现的类型声明 1234567891011struct Node;typedef struct Node *PtrToNode;typedef PtrToNode Stack;int IsEmpty(Stack S);Stack CreateStack(void);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S); 测试栈是否空栈的例程* 1234int IsEmpty(Stack S)&#123; return S-&gt;Next == NULL;&#125; 创建一个空栈的例程 1234567891011121314151617181920Stack CreateStack(void)&#123; Stack S; S = malloc(sizeof(struct Node)); if(S == NULL) FatalError("Out of space!!"); S-&gt;Next == NULL; MakeEmpty(S); return S;&#125;//MakeEmpty设置Next指针指向NULLvoid MakeEmpty(Stack S)&#123; if(S == NULL) Error("Must use CreateStack First"); else while(!IsEmpty(S)) Pop(S);&#125; Push进栈的例程 1234567891011121314void Push(int X, Stack S)&#123; PtrToNode TmpCell; TmpCell - malloc(sizeof(struct Node)); if(TmpCell == NULL) FatalError("Out of space!!"); else &#123; TmpCell-&gt;Element = X; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell; &#125;&#125; 返回栈顶元素的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Next-&gt;Element; Error("Empty Stack"); return 0;&#125; 从栈弹出元素的例程 123456789101112void Pop(Stack S)&#123; PtrToNode FirstCell; if(IsEmpty(S)) Error("Empty Stack!"); else &#123; FirstCell = S-&gt;Next; S-&gt;Next = S-&gt;Next-&gt;Next; free(FirstCell); &#125;&#125; ​ 所有操作均花费常数时间，但对于malloc和free的调用是非常昂贵的。有的缺点可以通过使用第二个栈避免，该第二个栈初始时为空栈。当一个单元栋第一个栈弹出时，它只是被放到了第二个栈中，此后当第一个栈需要新单元时，它首先去检查第二个栈 数组实现数组实现的栈可以避免指针的操作。其惟一潜在危害就是我们需要提前声明一个数组的大小。但通常来说声明一个足够大而不至于浪费太多空间的数组并不是太过困难，因此数组实现是一种比较流行的做法。 栈的声明 1234567891011121314#define EmptyTOS (-1)#define MinStackSize (5)struct StackRecord;typedef struct StackRecord *Stack;int IsEmpty(Stack S);int IsFull(Stack S);Stack CreateStack(int MaxElements);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S);int TopAndPop(Stack S); 栈的创建 1234567891011121314151617Stack CreateStack(int MaxElements)&#123; Stack S; if(MaxElements &lt; MinStackSize) Error("Stack size is too small"); S = (Stack)malloc(sizeof(strct StackRecord)); if(S == NULL) FatalError("Out of Space!!!"); S-&gt;Array = (int *)malloc(sizeof(int) * MaxElements); if(S-&gt;Array == NULL) FatalError("Out of space!!!"); S-&gt;Capacity = MaxElements; MakeEmpty(S); return S;&#125; 栈的释放 12345678void DisposeStack(Stack S)&#123; if(S != NULL) &#123; free(S-&gt;Array); free(S); &#125;&#125; 检测是否空栈 1234int IsEmpty(Stack S)&#123; return S-&gt;TopOfStack == EmptyTOS;&#125; 创建一个空栈 1234void MakeEmpty(Stack S)&#123; S-&gt;TopOfStack = EmptyTOS;&#125; 进栈的例程 1234567void Push(int X, Stack S)&#123; if(IsFull(S)) Error("Full stack"); else S-&gt;Array[++S-&gt;TopOfStack] = X;&#125; 将栈顶返回的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Array[S-&gt;TopOfStack]; Error("Empty stack"); return 0;&#125; 从栈弹出元素的例程 1234567void Pop(Stack S)&#123; if(IsEmpty(S)) Error("Empty stack"); else S-&gt;TopOfStack--;&#125; 应用待续。。。。。。]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念船新SI单位——"陈俊鹏"的诞生]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[为什么是“陈俊鹏”？事情还得从2000年2月31日一个婴儿的出生说起…… 出生 2000年2月31日，在成都市的一处郊区，一个婴儿出生了。2月31日，那是10000000000000年都难得一遇的日子，由此可见，在这一天出生的那个婴儿，其身份也并不一般。原来，他是天上的火爆龙神，由于长得太过帅气，惹得天帝嫉妒，将其贬下凡间，投胎在一户富贵人家。那一天，风雨大作，紫气东来，连天上的云都连成了一个“帅”字。地球有史以来最帅的人————陈俊鹏，出生了。 成长 陈俊鹏出生在富贵人家，每天从两万平米的床上醒来，由四万个女仆照顾他的生活起居，吃的是天山万年雪莲，喝的是珠穆朗玛峰上的万年寒冰化成的水，他的颜值自然越来越高。到5岁时，就已经帅得天怒人怨。在18岁时，更是超过了当时的世界第一美男子————蔡徐鲲。每一个见到他的人，都被他那帅气的脸庞直接帅晕了过去。自此，世界各国都被这样一个帅气的人给惊动了。 创立新的SI单位 “帅”是一个抽象的概念，人们一直没法量化。直到陈俊鹏为世界所知，科学家们一致认为，可以用陈俊鹏作为单位，来量化“帅”这个概念，而恰好“俊”又是“帅”的意思，不得不说，陈俊鹏真实造物者赐给科学界的无上宝物。于是，继长度（米）、质量（千克）、时间（秒）、电流（安培）、热力学温度（开尔文）、物质的量（摩尔）和发光强度（坎德拉）之后，新的SI单位————颜值高度（陈俊鹏）诞生了。 简述“陈俊鹏”定义 1陈俊鹏被定义为在常温常压下，能见度一般（10到20公里）的情况下，能够使至少一个身体健康的（无特殊疾病）人因为你的颜值而激动至昏迷的颜值。简称俊，写作cjp。 使用 由于陈俊鹏是很大的单位，除了陈俊鹏本人以外没人能够达到，于是我们常常使用微陈俊鹏（μcjp），纳陈俊鹏（ncjp），皮陈俊鹏（pcjp）来表示颜值，一个正常人的颜值大约为5pcjp，能达到μcjp的人，就已经算帅得惊天地泣鬼神了。（注：蔡徐鲲的颜值为5μcjp） 附录最后附上几张陈俊鹏的帅照（请读者克制住自己犯罪的欲望）]]></content>
      <categories>
        <category>CJP</category>
      </categories>
      <tags>
        <tag>-SI -陈俊鹏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>1</category>
      </categories>
  </entry>
</search>
