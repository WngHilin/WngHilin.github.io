<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript简要学习]]></title>
    <url>%2FJavascript%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介JavaScript： 是基于对象和事件驱动的语言，应用于客户端 基于对象： 提供了很多对象，可直接使用 事件驱动： 可以实现动态效果 客户端：指浏览器 特点： 交互性 信息的动态交互 安全性： js不能访问本地磁盘的文件 跨平台性： 通过浏览器实现 组成： （1）ECMAScript ECMA ：欧洲计算机协会 由ECMA组织指定的js语法和语句 （2）BOM browser object model 浏览器对象模型 （3）DOM document object model 文档对象模型 使用JS和HTML的结合方式 （1）使用script标签 1&lt;script type="text/javascript"&gt;&lt;/script&gt; （2）引入外部的js文件 1&lt;script type="text/javascript" srt="*.js"&gt;&lt;/script&gt; script标签放置：可以放在任何位置，但html是从上到下解析，所以最好放在后面，否则JavaScript可能获取不到input等标签里面的值。 原始类型和声明变量 js是弱类型语言 定义变量 使用关键字var 原始类型： string：字符串 1var str = "abc"; number：数字类型 1var num = 123; boolean：true or false null：获取对象的引用，null表示对象引用为空 1var date = new Date(); undefined：定义一个变量，没有赋值 1var aa; typeof()：可以查看变量的类型 语句 种类： if判断 switch语句：js所有类型都支持 循环 for while do-while 1234for(var i = 0; i &lt; 5; i++)&#123; &#125; 与java类似 运算符 与java中不同的： js中不区分整数和小数，123 / 1000 == 0.123 字符串相加和相减： “456” + 1 == “4561”（相加做字符串连接） “456” - 1 == “455”（相减进行真正的相减） “abc” - 1会提示NaN表示不是一个数字 boolean操作： true + 1 == 2 false + 1 == 1 即true是1，false是0 “ === ”和“ == ”： ==：值是否相等 ===：值和类型是否相等 补充：document.write()： 直接向页面写入内容，可以写入变量，固定值，html代码 数组 定义： （1）var[] arr = {1, 2, 3}; //数组可以存放不同的数据类型 （2）使用内置Array对象 1var arr1 = new Array(5); //建立有5个元素的数组 1var arr2 = new Array(3, 4, 5); //创建数组&#123;3, 4, 5&#125; 属性： （1）length：arr.length; 深入学习数组 函数 定义函数： （1）使用function关键字 12345function 方法名(参数列表)&#123; 方法体; （返回值）;&#125;//参数列表直接写参数名称，不用写var （2）匿名函数 123var 方法名 = function(参数列表)&#123; 方法体和返回值;&#125; （3）使用内置对象Function 12var add = new Function("参数列表", "方法体和返回值");//使用较少 全局变量和局部变量 全局变量：在script标签里定义一个变量，其在整个页面的js部分都可使用 方法内外，在另一个script标签使用 局部变量：在方法内部定义一个变量，只能在方法内部使用 重载 定义：函数名相同，函数参数列表不同(参数个数和参数类型)，根据参数不同去执行不同操作，但在js中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的。故JavaScript没有真正意义上的重载。 深入String对象 创建： 1var str = "abc"; 属性： length：字符串的长度 方法： （1）与HTML相关： bold：实现加粗 1document.write(str.bold()); fontcolor：修改字符串的颜色 1str2.fontcolor("red"); fontsize：修改字体大小 1str3.fontsize(5); link：将字符串显示为超链接 1str4.link("wnghilin.top"); sub、sup：将字符串显示为上下标 （2）与Java类似： concat：连接两个字符串 123456var str1 = "abc";var str2 = "gds";document.write(str1.concat(str2));输出结果：abcgds charAt：返回指定位置的字符 123var str3 = "abcdefg";str3.charAt(0);//返回astr3.charAt(20);//返回空字符串 indexOf：返回字符串位置，若不存在，返回-1 split：切分字符串，分为数组 12var str4 = "a-b-c-d";var arr1 = str4.split("-"); replace：替换字符串 1str6.replace("a", "6"); substr 和 substring：截取子字符串 123var str5 = "abcdefghuiop";str5.substr(5, 3); //fgh 从5开始向后开始截取3个字符str5.substring(3, 5); //de 从3位开始，第5位结束但不包含第5位 Array对象 创建：链接 属性： length：数组的长度 方法： concat：数组拼接，用法类似字符串 join：根据指定字符分隔数组 123var arr = new Array("a", "b", "c");document.write(arr); //输出：a, b, cdocument.write(arr.join("-")); //输出：a-b-c push：向数组末尾添加一个或多个新的元素，并返回数组新的长度 &lt;注&gt;如果向末尾添加的是数组，会将整个数组看作一个元素将其加入到原有数组中 pop：删除并返回最后一个元素 reverse：反转数组 Date对象 获取当前时间 123var date = new Date();date; //Fri Aug 02 2019 15:51:13 GMT+0800 (中国标准时间)date.toLocaleString();// 2019/8/2 下午3:53:45 获取当前年月日和星期 1234date.getFullYear(); //2019date.getMonth(); //7，因为返回结果是0-11月，需要再加一返回真实月数date.getDate(); //2date.getDay(); //5，返回0-6，星期日是0 获取当前时分秒 123date.getHours(); //16date.getMinutes(); //5date.getSeconds(); //36 获取毫秒数： 1date.getTime(); //1564733221660，1970年1月1日至今的毫秒数 Math对象都是静态方法，只能通过类名+方法调用 方法： cell：上舍入 floor：下舍入 round：四舍五入 random：产生0.0到1.0之间的随机数 属性 PI：圆周率 E：自然对数的底数 全局函数 不属于任何对象，致谢写名称使用 eval：如果字符串是js代码，使用该方法直接执行 12var str = "alert(1234)";eval(str); //执行alert(1234) encodeURI 和 decodeURI：对字符进行编码和解码 将中文先编码再解码可以有效防止乱码 encodeURIComponent 和 decodeURIComponent： 与上面只有编码字符多少的差别 isNaN：判断当前字符串是否是数字，若是，返回false parseInt：解析字符串并返回一个整数 重载有没有重载？链接 重载可模拟实现 使用arguments对象实现，这个方法的缺点是麻烦。 1234567function overload()&#123; if(arguments.length === 1) console.log('一个参数'); else if(arguments.length === 2) console.log('两个参数');&#125;//参数通过arguments[0]...来使用 BOM对象 BOM：浏览器对象模型 有哪些对象： navigator：可以货期客户机的信息（浏览器的信息） navigator.appName; //显示浏览器的名称 screen：可返回屏幕信息 screen.width; //返回屏幕的宽 screen.height; //返回屏幕的高 location：请求url地址 href属性 获取请求的url地址，即浏览器地址栏的地址 设置url地址 可以设置页面按钮的事件，将其跳转到另外一个页面 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="跳转" onclick="href1()"&gt;&lt;/input&gt;&lt;/body&gt;&lt;script&gt; function href1() &#123; location.href="http://www.baidu.com"; &#125;&lt;/script&gt;&lt;/html&gt; history：请求url的历史记录 可以通过其实现浏览器前进后退功能 history.back(); //到上一个页面 history.forward(); //到下一个页面 history.go(1); //到下一个页面 history.go(-1); //到下一个页面 window window对象 窗口对象 顶层对象（所用的bom对象都是在window对象的里面操作的） 方法： window.alert()：弹出一个消息提示框 简写alert(); confirm()：确认提示框，参数为提示内容 返回值：若点击确认，则返回true，否则返回false prompt(text, defaultText)：输入对话框 text为提示输入，defaultText为默认输入内容 open(URL,name,features,replace)：打开一个新窗口，并返回窗口对象 URL： 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name： 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 *target *的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features： 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace： 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值： **true - URL**： 替换浏览历史中的当前条目。​ false - URL： 在浏览历史中创建新的条目。 close()：关闭窗口，浏览器兼容性较差 做定时器： setInterval(code, millisec)：每millisec毫秒执行一次code代码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS简要学习]]></title>
    <url>%2Fcss%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSS简介 css：层叠样式表 样式表：有很多属性和属性值 css可以使得页面显示效果更好，可以提高后期样式代码的可维护性 CSS使用CSS和HTML的四种结合方式 （1）style属性： 1&lt;div style = "background-color:red;color:green"&gt;内容&lt;/div&gt; style属性示例 （2） style标签： 123456&lt;!--- 此处可以设置&lt;div&gt;标签的样式 ---&gt;&lt;style type="text/css"&gt; div&#123; css代码; &#125;&lt;/style&gt; style标签示例 （3）在style标签 使用语句： 创建css文件（.css） 在style标签中使用@import url(css文件路径)； （4）使用头标签引入外部css文件 创建css文件 1&lt;link rel="stylesheet" type="text/css" href="css路径"&gt; 注：第三种方式在某些浏览器下不起作用，一般用第四种 CSS优先级优先级：即最终以哪一个样式为准 从上到下，从内到外，优先级从低到高。（一般情况） 即html中，以在下方的和内部的样式为准 格式：选择器名称{属性名: 属性值; ······} CSS基本选择器种类 （1）标签选择器：用标签的名称作为选择器 （2）class选择器： 每个html标签都有个属性 class 123&lt;!--- 此处可以用class1作为选择器 ---&gt;&lt;div class="class1"&gt;&lt;/div&gt;&lt;p class="class1"&gt;&lt;/p&gt; 1234567div.class1&#123; css代码;&#125;/*此处修改所有class属性为class1的样式*/.class1&#123; css代码；&#125; （3）id选择器： 1&lt;div id="id1"&gt;&lt;/div&gt; 1234567div#id1&#123; css代码;&#125;/*此处修改所有id属性为id1的样式*/#id1&#123; css代码;&#125; 优先级 id选择器 &gt; class选择器 &gt; 标签选择器 CSS扩展选择器 （1）关联选择器 123&lt;div&gt;&lt;p&gt; 内容 &lt;/p&gt;&lt;/div&gt; 设置嵌套标签里的样式： 1234/*div里的p标签*/div p&#123; css代码;&#125; （2）组合选择器 12345&lt;div&gt; &lt;p&gt; 内容 &lt;/p&gt;&lt;/div&gt; 将div和p设置为相同样式 123div,p&#123; css代码;&#125; （3）伪元素选择器 css提供的定义好的样式，可以直接选用 比如超链接： 状态：原始 悬停 点击 点击后 原始： :link 悬停： :hover 点击： :active 点击后： :visited 123a:hover&#123; css代码;&#125; CSS盒子模型在布局前需要把数据装到一块一块的区域内，这个区域叫做盒子。 Margin(外边距) - 清除边框外的区域，外边距是透明的。 与边框类似 Border(边框) - 围绕在内边距和内容外的边框。 上：border-top 下：border-bottom 左：border-left 右：border-right 12345678/*统一设置*/div&#123; border: 2px solid blue;&#125;/*分别设置*/div#id1&#123; border-left: 2px dashed yellow;&#125; Padding(内边距) - 清除内容周围的区域，内边距是透明的。 与边框类似 Content(内容) - 盒子的内容，显示文本和图像。 布局的漂浮 float: 用于设置布局悬浮 none: 默认值，对象不漂浮。 left: 文本流向对象的右边。（其后面的部分漂向它的右边，空出的位置由剩下的补齐） right: 文本流向对象的左边。 缺点：在某些浏览器上无法使用 布局的定位 position: 用于设置布局定位 absolute: 将对象从文档流中拖出，其原来的位置由后面的补上 可用 top、left等对它进行绝对定位。 relative: 不从文档流中拖出，其余盒子位置不变 学习资料：(28天完整版)JavaWeb视频教程 资料、图片来源：CSS 盒子模型]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射————框架设计的灵魂]]></title>
    <url>%2F%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6%E7%9A%84%E7%81%B5%E9%AD%82%2F</url>
    <content type="text"><![CDATA[框架：软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。也被称为半成品软件。可以在框架的基础上进行软件开发，可以简化编码。 概念 反射：将类的各个组成部分封装为其他对象，这就是反射机制。（在Class 类对象阶段，将.class文件的各个部分封装成不同的类对象，如将成员变量封装成Field类对象并用数组存储起来。其总体是由class类对象储存的） 好处：* 1.可以在程序运行过程中操作这些对象。 * 2.可以解耦 获取字节码class对象的三种方式 获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 class类对象的获取功能 Class对象功能： 获取功能： 获取成员变量： Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 1234567891011//用法示例public class reflectDemo &#123; public static void main(String[] args) &#123; Class&lt;Person&gt; personClass = Person.class; Field[] fields = personClass.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125; Field a = personClass.getField("a"); &#125;&#125; 2. 获取构造方法： * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() Field：成员变量 操作： 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Junit进行单元测试]]></title>
    <url>%2FJunit%2F</url>
    <content type="text"><![CDATA[预备知识 黑箱测试：不需要输入代码，只看输入输出 白箱测试：需要输入代码进行测试 （其中，使用Junit进行测试是白箱测试 ） Junit使用 步骤： 定义一个测试类 ​ 建议使用被测试的类名+Test命名 ​ 可以建立一个新的test包储存测试类 定义测试方法，该测试方法可以独立运行： ​ 加上@Test，如下方代码 1234@Testpublic void testAdd()&#123; &#125; 导入Junit依赖环境 使用断言来判断结果: 判定结果：红色：失败 绿色：成功 1234567@Testpublic void testAdd()&#123; Calculator c = new Calculator(); int result = c.add(1, 2); Assert.assertEquals(期望结果，运算结果)(2, result); //Assert.assertEquals(期望结果，运算结果)&#125; 失败结果： 123java.lang.AssertionError: Expected :2Actual :3 @Before @After方法1234567891011121314151617/** * 初始化方法 * 所有测试方法执行之前都将执行这个方法 */ @Before public void init()&#123; System.out.println("init..."); &#125; /** * 释放资源方法 * 所有测试方法执行之后都会自动执行这个方法 */ @After public void close()&#123; System.out.println("close..."); &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 树]]></title>
    <url>%2F%E7%AC%AC4%E7%AB%A0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[预备知识 树（tree）是一些节点的集合，其可以为空集；若它不为空集，则一棵树由根（root）节点 r 以及0个或多个非空的子树T1、T2……组成，其中每一刻的根都被来自根 r 的一条有向的边（edge）所连接。 树的实现实现树的一种方法可以是在每一个节点除数据外还要有一些指针，使得该节点的每一个儿子都有一个指针指向它。但由于节点的儿子个数未知且可能变化很大，因此只能通过将每个节点的所有儿子都放在树节点的链表中。 123456typedef struct TreeNode *PtrToNodestruct TreeNode&#123; ElementType Element; PtrToNode FirstChild; PtrToNode NextSibling;&#125;; 如图所示： 树的遍历及应用 先序遍历（preorder traversal）：在先序遍历中，对节点的处理工作是在它的诸儿子节点被处理之前（pre）进行的。其每个节点总的工作量为常数。其时间复杂度为O(N)。例子如下： 12345678910111213141516//计算机中的文件系统可以用一个树来表示static void ListDir(DirectoryOrFile D, int Depth)&#123; if(D is a legitimate entry) &#123; PrintName(D, Depth); if(D is a Directory) for each child, C, of D ListDir(C, Depth + 1); &#125;&#125;void ListDirectory(DirectoryOrFile D)&#123; ListDir(D, 0);&#125; 列出分级文件系统中目录的例程 后序遍历（postorder traversal）：在后序遍历中，在一个节点处的工作实在它的诸儿子节点被计算后（post）进行的。例子如下： 1234567891011121314static void SizeDirectory(DirectoryOrFile D)&#123; int TotalSize; TotalSize = 0; if(D is a legitimate entry) &#123; TotalSize = FileSize(D); if(D is a directory) for each child, C, of D TotalSize += SizeDirectory(C); &#125; return TotalSize;&#125; 计算一个目录大小的例程 ## 二叉树 二叉树（binary tree）是一棵树，其中每个节点都不能有多于两个的儿子。 二叉树的深度可以远小于N，而其平均深度可以达到：$O(\sqrt(N))$，而二叉树的特殊情况，二叉查找树的深度平均值可以达到O(logN)。 实现 二叉树的一个节点就是由Key(关键字)信息加上两个指向其他节点的指针(Left和Right)组成的结构。 123456789typedef struct TreeNode *PtrToNode;typedef struct PtrToNode Tree;struct TreeNode&#123; ElementType Element; Tree Left; Tree Right;&#125;; 表达式树表达式树的树叶是操作数，如常数或变量，而其他节点为操作符（需要所有操作都是二元的）。 这种先读左儿子，再读节点，再读右儿子得到中缀表达式的方法，称为中序遍历，而采用后序遍历将会得到后缀表达式。 构造一颗表达式树设输入为$$a b + c d e + * *$$前两个符号式操作数，因此我们创建两颗单节点树并把指向它们的指针压入栈中： 接着，“ + ”被读入，指向这两棵树的指针被弹出，形成一棵新的树： 随后，c、d、e被读入，同理，压入栈中： 接下来读入“ + ”号，d、e弹出并合并。继续读读到“ * ”号，再将两棵树合并，结果为： 随后同理，即可得到最终结果。 查找树ADT——二叉查找树性质 对于树中的每个节点X，它的左子树中的所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。这意味着，该树所有的元素都可以用某种统一的方式排序。 MakeEmpty123456789101112131415161718typedef SearchTree *Node;struct Node&#123; int element; SearchTree left; SearchTree right;&#125;;SearchTree MakeEmpty(SearchTree tree)&#123; if (tree != NULL) &#123; MakeEmpty(tree-&gt;left); MakeEmpty(tree-&gt;right); free(tree); &#125; return NULL; Find123456789101112typedef struct TreeNode *Position;Position Find(ElementType X, SearchTree T)&#123; if(T == NULL) return NULL; if(X &lt; T-&gt;Element) return Find(X, T-&gt;Left); else if (X &gt; T-&gt;Element) return Find(X, T-&gt;Right); else return T;&#125; FindMin 和 FindMax123456789101112131415161718//以下分别采用了递归和非递归的方法来实现Position FindMin(SearchTree T)&#123; if(T == NULL) return NULL; else if(T-&gt;Left == NULL) return T; else return FindMin(T-&gt;Left);&#125;Position FindMax(SearchTree T)&#123; if(T != NULL) while(T -&gt; NULL) T = T-&gt;Right; return T;&#125; Insert123456789101112131415161718192021SearchTree Insert(ElementType X, SearchTree T)&#123; if(T == NULL) &#123; //建立并返回一个单节点树 T = (SearchTree)malloc(sizeof(struct TreeNode)); if(T == NULL) FatalError("Out of space!!!"); else &#123; T-&gt;Element = X; T-&gt;Left = T-&gt;Right = NULL; &#125; &#125; else if(X &lt; T-&gt;Element) T-&gt;Left = Insert(X, T-&gt;Left); else if(X &gt; T-&gt;Element) T-&gt;Right = Insert(X, T-&gt;Right); //如果X已经在树里面，则不进行操作 return T;&#125; Delete删除是最困难的操作。如果节点是一片树叶，那么它可以被立即删除。如果节点有一个儿子，则该节点可以在其父节点跳帧指针绕过该节点后被删除。如图： 删除具有两个儿子的节点，一般的策略是用其右子树的最小的数据代替该节点的数据并递归地删除那个节点。 12345678910111213141516171819202122232425262728SearchTree Delete(ElementType X, SearchTree T)&#123; Position TmpCell; if(T == NULL) Error("Element Not Found"); else if(X &lt; T-&gt;Element) T-&gt;Left = Delete(X, T-&gt;Left); else if(x &gt; T-&gt;Element) T-&gt;Right = Delete(X, T-&gt;Right); else if(T-&gt;Left &amp;&amp; T-&gt;Right) &#123; TmpCell = FindMin(T-&gt;Right); T-&gt;Element = TmpCell-&gt;Element; T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right); &#125; else //1个或0个儿子 &#123; TmpCell = T; if(T-&gt;Left == NULL) T = T-&gt;Right; else if(T-&gt;Right == NULL) T = T-&gt;Left; free(TmpCell); &#125; return T;&#125; AVL树性质 AVL树是带有平衡条件的二叉查找树。这个平衡条件必须容易保持，且它须保证树的深度是O(logN). 一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1。） 旋转在插入一个节点后，可能会破坏AVL树的特性，如果发生这种情况，那么就要把性质恢复以后才认为这一步插入完成。事实上，这总可以通过旋转（rotation）做到。 不平衡可能出现的情况： 对$\alpha$的左儿子的左子树进行一次插入。 对$\alpha$的左儿子的右子树进行一次插入。 对$\alpha$的右儿子的左子树进行一次插入。 对$\alpha$的右儿子的右子树进行一次插入。 左-左（或右-右）的情况需要进行一次单旋转（single rotation）而完成调整，另外两种需要进行一次双旋转（double rotation）。 单旋转左子树的左子树变为节点的左子树，在将原来的左子树变为右子树，原来的右子树变为右子树的右子树。 单旋转修复情形1]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 表、栈和队列]]></title>
    <url>%2F%E7%AC%AC3%E7%AB%A0%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[表ADT基本概念​ 空表（empty list）：大小为0的表。 ​ 前驱元、后继元。 链表函数原型 123456789101112struct Node;typedef struct Node *PtrToNode;typedef PtrToNode List;typedef PtrToNode Position;List MakeEmpty(List L);int IsEmpty(List L);int IsLast(Position P, List L);Position Find(int X, List L);void Insert(int X, List L, Position P);void DeleteList(List L);Position Header(List L); 具体实现：略 常见的错误链表一般会出现指针变量包含了伪地址的问题。删除表时，需要一个中间量来储存上一个节点。同时，使用malloc之后记得将该节点初始化。 例子多项式ADT令F(X) = ∑i=0N AiXi。如果多项式的次数过大，使用普通方法的运行时间就难以接受了。于是可以采用多项式ADT来实现多项式的加减乘等操作。 多项式ADT的数组实现的类型声明 12345typedef struct&#123; int CoeffArray[MaxDegree + 1]; int HighPower;&#125; * Polynomial; 将多项式初始化为零的过程 12345678void ZeroPolynomial(Polynomial Poly)&#123; int i; for(i = 0; i &lt;= MaxDegree; i++) Poly-&gt;CoeffArray[i] = 0; Poly-&gt;HighPower = 0;&#125; 两个多项式相加的过程 12345678void AddPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolySum)&#123; int i; ZeroPolynomial(PolySum); PolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower); for(i = PolySum-&gt;HighPower; i &gt;= 0; i--) PolySum-&gt;CoeffArray[i] = Poly1-&gt;CoeffArray[i] + Poly2-&gt;CoeffArray[i];&#125; 两个多项式相乘的过程 12345678910111213void MultPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)&#123; int i, j; ZeroPolynomial(PolyProd); PolySum-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower; if(PolyProd-&gt;HighPower &gt; MaxDegree) Error("Exceeded array size"); else for(i = 0; i &lt;= Poly1-&gt;HighPower; i++) for(j = 0; j &lt;= Poly2-&gt;HighPower; j++) PolyProd-&gt;CoeffArray[i + j] += Poly1-&gt;CoeffArray[i] * Poly2-&gt;CoeffArray[j];&#125; 栈ADT栈模型栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，即顶（top）。对栈的基本操作有Push和Pop。 栈有时又叫LIFO(后进先出)表。 栈的实现链表实现栈ADT链表实现的类型声明 1234567891011struct Node;typedef struct Node *PtrToNode;typedef PtrToNode Stack;int IsEmpty(Stack S);Stack CreateStack(void);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S); 测试栈是否空栈的例程* 1234int IsEmpty(Stack S)&#123; return S-&gt;Next == NULL;&#125; 创建一个空栈的例程 1234567891011121314151617181920Stack CreateStack(void)&#123; Stack S; S = malloc(sizeof(struct Node)); if(S == NULL) FatalError("Out of space!!"); S-&gt;Next == NULL; MakeEmpty(S); return S;&#125;//MakeEmpty设置Next指针指向NULLvoid MakeEmpty(Stack S)&#123; if(S == NULL) Error("Must use CreateStack First"); else while(!IsEmpty(S)) Pop(S);&#125; Push进栈的例程 1234567891011121314void Push(int X, Stack S)&#123; PtrToNode TmpCell; TmpCell - malloc(sizeof(struct Node)); if(TmpCell == NULL) FatalError("Out of space!!"); else &#123; TmpCell-&gt;Element = X; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell; &#125;&#125; 返回栈顶元素的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Next-&gt;Element; Error("Empty Stack"); return 0;&#125; 从栈弹出元素的例程 123456789101112void Pop(Stack S)&#123; PtrToNode FirstCell; if(IsEmpty(S)) Error("Empty Stack!"); else &#123; FirstCell = S-&gt;Next; S-&gt;Next = S-&gt;Next-&gt;Next; free(FirstCell); &#125;&#125; ​ 所有操作均花费常数时间，但对于malloc和free的调用是非常昂贵的。有的缺点可以通过使用第二个栈避免，该第二个栈初始时为空栈。当一个单元栋第一个栈弹出时，它只是被放到了第二个栈中，此后当第一个栈需要新单元时，它首先去检查第二个栈 数组实现数组实现的栈可以避免指针的操作。其惟一潜在危害就是我们需要提前声明一个数组的大小。但通常来说声明一个足够大而不至于浪费太多空间的数组并不是太过困难，因此数组实现是一种比较流行的做法。 栈的声明 1234567891011121314#define EmptyTOS (-1)#define MinStackSize (5)struct StackRecord;typedef struct StackRecord *Stack;int IsEmpty(Stack S);int IsFull(Stack S);Stack CreateStack(int MaxElements);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S);int TopAndPop(Stack S); 栈的创建 1234567891011121314151617Stack CreateStack(int MaxElements)&#123; Stack S; if(MaxElements &lt; MinStackSize) Error("Stack size is too small"); S = (Stack)malloc(sizeof(strct StackRecord)); if(S == NULL) FatalError("Out of Space!!!"); S-&gt;Array = (int *)malloc(sizeof(int) * MaxElements); if(S-&gt;Array == NULL) FatalError("Out of space!!!"); S-&gt;Capacity = MaxElements; MakeEmpty(S); return S;&#125; 栈的释放 12345678void DisposeStack(Stack S)&#123; if(S != NULL) &#123; free(S-&gt;Array); free(S); &#125;&#125; 检测是否空栈 1234int IsEmpty(Stack S)&#123; return S-&gt;TopOfStack == EmptyTOS;&#125; 创建一个空栈 1234void MakeEmpty(Stack S)&#123; S-&gt;TopOfStack = EmptyTOS;&#125; 进栈的例程 1234567void Push(int X, Stack S)&#123; if(IsFull(S)) Error("Full stack"); else S-&gt;Array[++S-&gt;TopOfStack] = X;&#125; 将栈顶返回的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Array[S-&gt;TopOfStack]; Error("Empty stack"); return 0;&#125; 从栈弹出元素的例程 1234567void Pop(Stack S)&#123; if(IsEmpty(S)) Error("Empty stack"); else S-&gt;TopOfStack--;&#125; 应用平衡符号做一个空栈。读入字符知道文件尾。如果字符时一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则当栈空时报错。否则，将栈元素弹出，如果弹出的符号不是对应的开放符号，则报错。在文件尾，如果栈非空则报错。 后缀表达式中缀表达式：4.99 + 5.99 + 6.99 * 1.06 后缀表达式：4.99 1.06 * 5.99 + 6.99 1.06 * + （后缀（postfix）或逆波兰（reverse Polish）记法） 计算后缀表达式的方法是使用一个栈，当见到一个数字时就把它推入到栈中；遇到一个运算符时该运算符就作用于从该栈弹出的两个数（符号）上，将所得结果推入栈中。 如，计算 *6 5 3 2 + 8 * + 3 + * *： TopOfStack-&gt; 3 2 5 6 下面读到一个‘+’，所以3和2被弹出，其结果5被压入栈中： TopOfStack-&gt; 5 5 6 接着，8进栈： TopOfStack-&gt; 8 5 5 6 然后，8和5弹出，相乘，再将40压入栈中： TopOfStack-&gt; 40 5 6 接着又遇到‘+’号，因此40和5被弹出，并且40 + 5 = 45进栈： TopOfStack-&gt; 45 6 随后操作同上，得到结果288。 中缀到后缀的转换设我们想将中缀表达式： a + b * c + (d * e + f) * g 转换成后缀表达式，其答案为 a b c * + d e * f + g * + 首先，a被读入，于是它流向输出。然后，“+”被读入并被放入栈中。接着b读入并流向输出： Stack Output + a b 这时“ * ”读入。操作符栈顶元素比较低，故没有输出，“ * ”进栈。接着c被读入并输出： Stack Output * + a b c 后面是一个“ + ”号。其优先级比“ * ”低，因此将“ * ”从栈弹出并放入输出中；弹出剩下的“ + ”，因为其不比“ + ”优先级低，而是具有相同的优先级，然后将“ + ”压入栈中。 Stack Output + a b c * + 随后操作同上，需要注意的是“ （ ”的优先级最高，遇到“ ）”时要将所有符号弹出，直到遇到” （ “。 函数调用​ 尾递归（tail recursion）是使用递归极端不当的例子。尾递归可以通过将递归调用变成goto语句并在其前加上对每个函数的赋值语句而手动消除。很多编译器都能自动消除尾递归，但最好还是通过手动进行消除。 队列ADT队列模型​ 队列的基本操作是Enqueue和Dequeue。 队列的数组实现​ 对于每一个队列数据结构，我们保留一个数组Queue[ ]以及Front和Rear，还有记录实际存在于队列中的元素的个数Size。 ​ 为使一个元素X入队，我们让Size和Rear都增加1，然后置Queue[ Rear] = X。若使一个元素出队，我们置返回值为Queue[front]，Size减1，然后让Front增加1。 ​ 为了防止不出界，该操作需要使用循环数组（circular array）实现。 队列的类型声明 123456789101112struct QueueRecord;typedef struct QueueRecord *Queue;int IsEmpty(Queue Q);int IsFull(Queue Q);Queue CreateQueue(int MaxElements);void DisposeQueue(Queue Q);void MakeEmpty(Queue Q);void Enqueue(int X, Queue Q);int Front(Queue Q);void Dequeue(Queue Q);int FrotAndDequeue(Queue Q); 测试队列是否为空的例程 1234int IsEmpty(Queue Q)&#123; return Q-&gt;Size == 0;&#125; 构造空队列的例程 123456void MakeEmpty(Queue Q)&#123; Q-&gt;Size = 0; Q-&gt;Front = 1; Q-&gt;Rear = 0;&#125; 入队的例程 1234567891011121314151617static int Succ(int Value, Queue Q)&#123; if(++Value == Q-&gt;Capacity) Value = 0; return Value;&#125;void Enqueue(int X, Queue Q)&#123; if(IsFull(Q)) Error("Full queue"); else &#123; Q-&gt;Size++; Q-&gt;Rear = Succ(Q-&gt;Rear, Q); Q-&gt;Array[Q-&gt;Rear] = X; &#125;&#125; 出队的例程 12345678910111213void Dequeue(Queue Q)&#123; int returnNum; if(IsEmpty(Q)) Error("Empty Queue"); else &#123; returnNum = Q-&gt;Array[Q-&gt;Front]; Q-&gt;Front = Succ(Q-&gt;Front, Q); Q-&gt;Size--; return returnNum; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念船新SI单位——"陈俊鹏"的诞生]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[为什么是“陈俊鹏”？事情还得从2000年2月31日一个婴儿的出生说起…… 出生 2000年2月31日，在成都市的一处郊区，一个婴儿出生了。2月31日，那是10000000000000年都难得一遇的日子，由此可见，在这一天出生的那个婴儿，其身份也并不一般。原来，他是天上的火爆龙神，由于长得太过帅气，惹得天帝嫉妒，将其贬下凡间，投胎在一户富贵人家。那一天，风雨大作，紫气东来，连天上的云都连成了一个“帅”字。地球有史以来最帅的人————陈俊鹏，出生了。 成长 陈俊鹏出生在富贵人家，每天从两万平米的床上醒来，由四万个女仆照顾他的生活起居，吃的是天山万年雪莲，喝的是珠穆朗玛峰上的万年寒冰化成的水，他的颜值自然越来越高。到5岁时，就已经帅得天怒人怨。在18岁时，更是超过了当时的世界第一美男子————蔡徐鲲。每一个见到他的人，都被他那帅气的脸庞直接帅晕了过去。自此，世界各国都被这样一个帅气的人给惊动了。 创立新的SI单位 “帅”是一个抽象的概念，人们一直没法量化。直到陈俊鹏为世界所知，科学家们一致认为，可以用陈俊鹏作为单位，来量化“帅”这个概念，而恰好“俊”又是“帅”的意思，不得不说，陈俊鹏真实造物者赐给科学界的无上宝物。于是，继长度（米）、质量（千克）、时间（秒）、电流（安培）、热力学温度（开尔文）、物质的量（摩尔）和发光强度（坎德拉）之后，新的SI单位————颜值高度（陈俊鹏）诞生了。 简述“陈俊鹏”定义 1陈俊鹏被定义为在常温常压下，能见度一般（10到20公里）的情况下，能够使至少一个身体健康的（无特殊疾病）人因为你的颜值而激动至昏迷的颜值。简称俊，写作cjp。 使用 由于陈俊鹏是很大的单位，除了陈俊鹏本人以外没人能够达到，于是我们常常使用微陈俊鹏（μcjp），纳陈俊鹏（ncjp），皮陈俊鹏（pcjp）来表示颜值，一个正常人的颜值大约为5pcjp，能达到μcjp的人，就已经算帅得惊天地泣鬼神了。（注：蔡徐鲲的颜值为5μcjp） 附录最后附上几张陈俊鹏的帅照（请读者克制住自己犯罪的欲望）]]></content>
      <categories>
        <category>CJP</category>
      </categories>
      <tags>
        <tag>-SI -陈俊鹏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>1</category>
      </categories>
  </entry>
</search>
