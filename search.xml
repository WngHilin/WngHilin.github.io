<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC学习]]></title>
    <url>%2FSpring-SpringMVC%2F</url>
    <content type="text"><![CDATA[初步理解 步骤 导入jar包 在web.xml中配置DispatcherServlet 加入SpringMVC配置文件 编写处理请求的处理器，并将其标识为处理器 编写视图]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaWeb</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringXML学习]]></title>
    <url>%2FSpring-SpringXML%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[IOC&amp;DI概述 IOC（Inversion of Control）：其思想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源，作为回应，容器适时地返回资源。而应用了IOC之后，则是容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源。 DI（Dependency Injection) ：—IOC的另一种表述方式：即组件以一些预先定义好的方式接收来自如容器的资源注入。 配置Bean通过全类名 通过全类名（反射）进行配置（在xml中使用bean标签） class：bean的全类名，通过反射的方式在IOC中其中创建Bean，所以要求Bean中必须有无参数的构造器 id：表示容器中的bean，id唯一。通过id找到相应的bean 123&lt;bean id="HelloWorld" class="top.wnghilin.test.HelloWorld"&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt;&lt;/bean&gt; 步骤： 对IOC容器进行实例化 BeanFactory ：IOC容器的基本实现 ApplicationContext：面向使用的Spring框架的开发者，基本都使用该方式 ApplicationContext的主要实现类： ClassPathXmlApplicationContext：从类路径下加载配置文件 FileSystemXmlApplicationContext：从文件系统中加载配置文件 WebApplicationContext是专门为web应用准备的，它允许从相对于WEB根目录的路径中完成初始化工作。 从ApplicationContext中读取Bean的方法 通过id读取：getBean(“id值”); 用类型获取：getBean(类名.class); //缺点：要求是唯一的Bean Spring的依赖注入方法 属性注入：通过setter方法注入Bean的属性值或以来对象 使用&lt;property&gt;元素的name属性指定Bean的属性名称，value属性或&lt;value&gt;子节点指定属性值 这种方式是最常用的注入方式 123&lt;bean id="HelloWorld" class="top.wnghilin.test.HelloWorld"&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt;&lt;/bean&gt; 构造方法注入： 12345&lt;bean id="car" class="top.wnghilin.test.Car"&gt; &lt;constructor-arg value="Audi" index="0" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHi" index="1" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="6000000" index="2" type="int"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; index为构造器中参数的编号，若不指定index属性，则默认按照参数顺序进行注入 type属性：指定参数的类型，用于区分重载的构造器 属性注入的一些细节 用value属性或value标签实现。如果有特殊字符，则用&lt;![CDATA[]]&gt;包裹起来 1&lt;value&gt;&lt;![CDATA[&lt;上海&gt;]]&gt;&lt;/value&gt; 可以用&lt;null/&gt;标签给某个属性注入null值 引用其它的Bean： 可以使用property的ref属性建立bean之间的引用关系（或&lt;ref&gt;属性） 1&lt;property name="car" ref="car2"&gt;&lt;/property&gt; 可以在Bean内部创造一个bean（内部Bean不能被外部引用） 1234567891011&lt;bean id="Person" class="top.wnghilin.test.Person"&gt; &lt;property name="name" value="Ford"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="car"&gt; &lt;bean class="top.wnghilin.test.Car"&gt; &lt;constructor-arg index="0" value="Fox"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="北京" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200" index="2"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; Spring支持级联属性的配置： 123&lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt;&lt;!-- 为级联属性赋值 --&gt;&lt;property name="car.maxSpeed" value="250"&gt;&lt;/property&gt; 注意：属性需要先初始化后才可以为级联属性赋值 集合属性：如果某个属性是集合类型的，用list元素包起来(数组也用list标签) 1234567891011&lt;bean id="Person" class="top.wnghilin.collection.Person"&gt; &lt;property name="name" value="Fox"&gt;&lt;/property&gt; &lt;property name="age" value="12"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;list&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car2"/&gt; &lt;ref bean="car3"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Set类型的属性需要用set标签 Map属性：用map标签包裹，entry标签指定值 123456&lt;property name="cars"&gt; &lt;map&gt; &lt;entry key="AA" value-ref="car"&gt;&lt;/entry&gt; &lt;entry key="BB" value-ref="car2"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; 使用props标签定义java.util.Properties，该标签使用多个prop作为子标签，每个prop标签必须定义key属性 配置单例的集合bean，以供多个bean进行引用，需要导入util命名空间 1234567891011&lt;util:list id="cars"&gt; &lt;ref bean="car2"/&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car3"/&gt; &lt;/util:list&gt; &lt;bean id="person4" class="top.wnghilin.collection.Person"&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;property name="age" value="29"&gt;&lt;/property&gt; &lt;property name="cars" ref="cars"&gt;&lt;/property&gt; &lt;/bean&gt; 使用p命名空间为bean的属性赋值： 导入p命名空间 使用p命名空间进行赋值 123&lt;bean id="person5" class="top.wnghilin.collection.Person" p:name="spring" p:age="30" p:cars-ref="cars"&gt;&lt;/bean&gt; 自动装配： IOC容器可以自动装配Bean，需要做的就是在&lt;bean&gt;的autowire属性里指定自动装配的模式 byType（根据类型自动装配）：根据bean的类型和当前bean的属性的类型进行自动装配。如果有多个类型一致的Bean，无法自动装配 byName（根据类型名称自动装配）：根据bean的名字和当前bean的setter风格属性名进行自动装配，若没有匹配的，则不装配。 constructor：不推荐使用 12&lt;bean id="person" class="top.wnghilin.autowire.Person" p:name="Tom" autowire="byName"&gt;&lt;/bean&gt; 缺点：不够灵活，实际开发中很少使用自动装配功能 Bean之间的关系 继承：使用parent属性指定继承哪个bean的配置，子bean可以覆盖父bean的配置 如果只想把父bean当作模板，可以把abstract属性设为true，这样其就不会被实例化 依赖：设置depends-on属性 Bean的作用域 使用scope属性设置作用于 singleton：单例的，默认值。容器初始时创建bean实例，在整个容器的生命周期内只创建这一次 prototype：原型的，每次向容器请求bean，都会产生一个新的bean，容器初始化时不创建bean的实例。 使用外部属性文件 Spring提供一个PropertyPlaceholderConfigurer的BeanFactory后置处理器，这个处理器允许用户将Bean配置的部分内容外移到属性文件中，可以在Bean配置文件里使用形式为 ${var} 的变量，该处理器从属性文件加载属性，并使用这些属性来替换变量。 Spring还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。 使用步骤： 导入属性文件： 使用外部化属性文件的属性 123456&lt;bean id="DB" class="top.wnghilin.properties.DB"&gt; &lt;property name="user" value="$&#123;user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="driverclass" value="$&#123;driverclass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcurl" value="$&#123;jdbcurl&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 工厂方法 静态工厂方法 设置静态工厂方法 123456789101112131415/** * 静态工厂方法：直接调用某一个类的静态方法就可以返回Bean的实例 */public class StaticCarFactory &#123; private static Map&lt;String, Car&gt; cars = new HashMap&lt;String, Car&gt;(); static &#123; cars.put("Audi", new Car("audi", 300000)); cars.put("Ford", new Car("Ford", 400000)); &#125; //静态工厂方法 public static Car getCar(String name)&#123; return cars.get(name); &#125;&#125; 配置静态工厂方法 123456&lt;bean id="car1" class="top.wnghilin.factory.StaticCarFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"/&gt;&lt;/bean&gt; factory-method：指向静态工厂方法的名字 constructor-arg：如果工厂方法需要传入参数，则使用该标签，来配置参数 实例工厂方法 设置实例工厂方法 12345678910111213141516/** * 实例工厂方法：实例工厂的方法，即先需要创建工厂本身，再调用工厂的实例方法来返回bean的实例 */public class InstanceCarFactory &#123; private Map&lt;String, Car&gt; cars = null; public InstanceCarFactory()&#123; cars = new HashMap&lt;String, Car&gt;(); cars.put("Audi", new Car("Audi", 500000)); cars.put("Ford", new Car("Ford", 400000)); &#125; public Car getCar(String brand)&#123; return cars.get(brand); &#125;&#125; 配置实例工厂方法 1234567&lt;!--配置工厂的实例--&gt;&lt;bean id="carFactory" class="top.wnghilin.factory.InstanceCarFactory"&gt;&lt;/bean&gt;&lt;!--通过实例工厂方法来配置bean--&gt;&lt;bean id="car2" factory-bean="carFactory" factory-method="getCar"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; FactoryBean 设置FactoryBean 12345678910111213141516171819202122232425262728public class CarFactoryBean implements FactoryBean &#123; private String brand; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; //返回Bean的对象 @Override public Object getObject() throws Exception &#123; return new Car(this.brand, 1000000); &#125; //返回Bean的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; //返回是不是单实例的 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 配置FactoryBean 123&lt;bean id="car" class="top.wnghilin.factoryBean.CarFactoryBean"&gt; &lt;property name="brand" value="BMW"&gt;&lt;/property&gt;&lt;/bean&gt; 实际返回的实例是FactoryBean的getObject方法返回的Bean 基于注解 组件扫描：Spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件 特定组件有： @Component：基本注解，标识了一个受Spring管理的组件 @Respository：标识持久层组件 @Service：标识服务层（业务层）组件 @Controller：标识表现层组件 对于扫描到的组件，Spring有默认的命名策略：使用非限定类名，第一个字母小写，也可以再注解中通过value属性值标识组件的名称 当在组件类上使用了特定的注解之后，还需要在Spring的配置文件中声明&lt;context:component-scan&gt; base-package属性指定一个需要扫描的基类包，Spring容器会扫描该包及其子包中的所有类 扫描多个包时，用逗号分隔 用resource-pattern来过滤特定的类 Bean中属性的值可以用@Value()指定，或者使用@Autowired，自动装配。根据类型来检测扫描容器当中符合这个属性类型的对象，如果检测到了，找到这个对象，赋值给这个属性。也可以使用@Qualifier指定装配特定的bean 123&lt;context:component-scan base-package="top.wnghilin.spring.beans", resource-pattern="autowire/*.class"/&gt; &lt;context:include-filter&gt;子节点表示要包含的目标类]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaWeb</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找或去除数组中重复元素的一些方法]]></title>
    <url>%2FAlgoEssay-%E6%95%B0%E7%BB%84%E6%9F%A5%E9%87%8D%2F</url>
    <content type="text"><![CDATA[​ 问题描述1：给定一个已经排序好的数组，你需要在原地删除掉已经重复的元素（用O(1)的额外空间进行处理）。如数组 [1, 2, 2, 3, 3, 4, 4, 4, 4] ，你需要使得该数组的前四位的数字为1，2，3，4，并返回其长度4。 ​ 问题描述2：给定一个范围在 0 到 n-1 之间的乱序数组(数组长度为n)，需要你找出重复的元素（无需注意顺序）。 ​ 问题描述3：给定一个长度为 n+1 的数组里的所有数字范围都在 1~n 范围内，要求不修改数组，找出重复的元素。 问题1​ 给定一个已经排序好的数组让去重，是一道非常简单的题。非常容易就可以想到，找出重复的元素，将其后面的元素依次向前移动(常见的数组删除操作)，就将这个重复元素去除了。然而数组的删除操作的时间复杂度为 O(n)，再加上数组的遍历操作，这个算法的时间复杂度就非常之高了。我们试图找出一个时间复杂度为 O(n) 的算法 双指针法​ 我们可以采用双指针定位法，开始时，指针 i ，j指向同一个元素，j开始向后移动，直到遇到第一个与i不相等的元素，将 i 增加1，再将 j 的值赋值给 i，这时 i 后的重复元素就被覆盖，继续重复操作，直到 j 到达数组的末尾，数组的开头就全部变成了非重复元素，图解如下： 代码如下： 12345678910public int removeDuplicates(int[] nums) &#123; int i = 0, j; for(j = 1; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125; 双指针法的其它应用​ 双指针法用处很广，并不一定只能用来查重 ​ 删除数组元素：问题需要我们就地删除给定值的所有元素，我们仍可以使用两个指针 i 和 j，用类似上方问题的方法来进行求解。 12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125; ​ 寻找数组的倒数第k个数字：使用两个指针 i 和 j，让 i 先走k-1步，随后再让两者同时开始走，当 i 到达数组末尾时，j 就恰好在数组倒数第 k 个位置上。但该解法需要注意边界条件的判断。比如，当数组(表)的长度小于k-1或者输入的k等于0时的判断。 ​ 替换空格：将一个字符串中的每一个空格都替换成”%20”。以”We are happy“为例。我们可以插入之前，都将后面的元素向后移动两格，但很显然，第一次和第二次替换空格时，happy都向后移动了，这就会导致该算法的时间复杂度达到O(n^2^)，而使用双指针法，可以保证其时间复杂度为 O(n)。详解如下： ​ 我们可以先遍历一遍数组，统计空格数量；由于每替换一个空格，数组长度就增加而，因此就可以得到替换后的数组长度：原来的长度加上2乘以空格数目。我们可以准备指针P~1~和P~2~，P~1~指向原始字符串的末尾，而P~2~指向替换后字符串末尾。随后移动P~1~，逐个将它指向的字符复制到和P~2~指向的位置，遇到空格之后，把P~1~向前移动1格，在P~2~之前插入”%20”，再将P~2~移动三个，直到P~1~和P~2~指向同一位置。图解如下： 代码： 123456789101112131415161718192021222324252627282930313233343536373839void ReplaceBlank(char string[], int length)&#123; if(string == NULL || length &lt; 0) return; int originalLength = 0; int numberOfBlank = 0; int i = 0; while(string[i] != '\0') &#123; ++originalLength; if(string[i] == ' ') ++numberOfBlank; ++i; &#125; int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; length) return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt;= indexOfOriginal) &#123; if(string[indexOfOriginal] == ' ') &#123; string[indexOfNew--] = '0'; string[indexOfNew--] = '2'; string[indexOfNew--] = '%'; &#125; else &#123; string[indexOfNew--] = string[indexOfOriginal]; &#125; --indexOfOriginal; &#125;&#125; 问题2​ 这个问题也并不难。很容易想到的方法就是先将数组排序，随后按照方法1的方式去除重复元素。但是，排序一个长度为 n 的数组需要 O(nlogn) 的时间(不考虑桶排序)。或者使用哈希表，遍历数组，如果表中还不存在这个数字，就把它加入表，如果已经存在，就找到了一个重复的数字。但这个方法需要额外支付一个大小为O(n)的哈希表。下面为空间复杂度为O(1)的方法。 ​ 从头到尾一次扫描这个数组中的数字，当扫描到下标为 i 的数字时，首先比较这个数字 m 是不是等于 i ，如果不是，则将它和第 m 个数字进行比较，如果相等，则找到了一个重复的数字(它在下标为 i 和 m 的位置都出现了)；如果不相等，则将第 i 和第 m 个数字交换，接下来重复这个过程，知道我们发现了一个重复的数字。图示如下： ​ 依此类推…… 代码： 1234567891011121314151617181920212223242526272829bool duplicate(int numbers[], int length, int* duplication)&#123; if(numbers == NULL || length &lt;= 0) return false; for(int i = 0; i &lt; length; ++i) &#123; if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1) return false; &#125; for(int i = 0; i &lt; length; ++i) &#123; while(numbers[i] != i) &#123; if(numbers[i] == numbers[numbers[i]]); &#123; *duplication = numbers[i]; return true; &#125; &#125; //交换numbers[i]和numbers[numbers[i]] int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; &#125; return false;&#125; ​ 找到的重复数字通过参数duplication传给函数的调用者，而返回值表示是否有重复数字。 ​ 代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于它自己的位置，因此总的时间复杂度是**O(n)（找到的重复元素再使用删除方法将其删除即可） 问题3​ 这道题可以创建 n+1 长度的辅助数组来完成。下面来尝试避免使用辅助空间。 ​ 如果没有重复数字，1~n的范围内只有n个数字，但由于超过了n个数字，故一定会有重复的数字。以长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}为例。该数组所有数字范围都在1-7范围内，4将该范围分为两段。统计1-4范围内数字出现的次数，一共出现5次，说明其中一定有重复数字。再将1-4范围一分为二，发现再数字1或2在数组出现了两次，3或4再数组中出现了3次，则3和4中一定有数字重复了。再如此找下去，就会发现3重复了。 123456789101112131415161718192021222324252627282930313233343536373839int getDuplication(const int *numbers, int length)&#123; if(numbers == NULL || length &lt;= 0) return -1; int start = 1; int end = length - 1; while(end &gt;= start) &#123; int middle = ((end - start) &gt;&gt; 1) + start; int count = countRange(numbers, length, start, middle); if(end == start) &#123; if(count &gt; 1) return start; else break; &#125; if(count &gt; (middle - start + 1)) end = middle; else start = middle + 1; &#125; return -1;&#125;int countRange(const int* numbers, int length, int start, int end)&#123; if(numbers == NULL) return 0; int count = 0; for(int i = 0; i &lt; length; i++) if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end) ++count; return count;&#125; ​ 时间复杂度为 O(nlogn) ，相当于用时间换空间，而且该算法不能保证找出所有重复数字。如1和2，我们无法确定是两个数字各出现一次还是一个数字出现两次。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>随笔</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目管理]]></title>
    <url>%2FJavaWeb-Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础 maven开发的项目，jar包不在项目中，项目保存的是jar包的坐标，jar包实际放在jar包仓库中。 依赖管理：maven工程对jar包的管理过程 构建项目：指的是从编译、测试、运行、打包、安装、部署整个过程都交给maven进行管理。 下载和安装 下载地址：http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.1/binaries/apache-maven-3.6.1-bin.zip 安装：解压即可 /conf/settings.xml用来配置maven的文件 配置环境变量 系统变量中新建值 path中新建值，输入%MAVEN_HOME%\bin(注意：必须确保环境中已经配置了JAVA_HOME) 确认是否配置完成：命令行中输入mvn -v maven仓库 打开./conf/settings.xml 可以看到默认位置，maven会在系统盘找本地仓库，如果本地仓库没有，它在联网状态下会在中央仓库下载（若未联网，则会报错） 修改仓库位置：在./conf/settings.xml中添加如下代码 maven标准目录结构 项目组成 核心代码部分 配置文件部分 测试代码部分 测试配置文件 标准目录结构 src/main/java 核心代码 src/main/resources 配置文件 src/test/java 测试代码 src/test/resources 测试配置文件 src/main/webapp 页面资源，js、css、图片等 使用 先进入项目目录 输入命令进行操作 命令： mvn clean：删除target目录，即删除已经编译好的内容 mvn compile：将核心代码文件编译为class文件 mvn test：将核心代码和测试代码编译为class文件 mvn package：将代码全部编译并打包成war包(可在settings.xml中进行配置) mvn install：将代码全部编译并打包成war包再将这个包安装到本地操作 概念模型图： IDEA集成maven 打开设置，搜索maven 选择好maven的安装目录 配置settings.xml和本地仓库的路径 配置Runner 使用骨架创建maven项目 创建Maven项目，选择quickstart骨架 配置好后点击相应的Mark Directory As… 导入jar包 打开pom文件 写入&lt;dependencies&gt;标签 如果本地没有该jar包 搜索maven中央仓库网页，查找需要的jar包 点击相应版本，复制其坐标到pom.xml 解决jar包冲突 在&lt;version&gt;标签下，添加&lt;scope&gt;标签改变其作用域 内容： provided：该jar包只在编译过程中起作用 test：该jar包只在测试过程中起作用]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis——高性能的非关系型数据库]]></title>
    <url>%2FJavaWebeb-redis%2F</url>
    <content type="text"><![CDATA[基础 概念：redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：https://www.redis.net.cn windows版本：https://github.com/MicrosoftArchive/redis/tags 安装：解压即可使用 redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis的服务器端 命令操作 redis的数据结构： redis存储的是：key, value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构 1) 字符串类型 string 2) 哈希类型 hash : map格式 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 字符串类型 string 存储：set key value 获取：get key 删除：del key 哈希类型 hash 存储：hset key field value 获取： 获取指定field对应的值：hget key field 获取所有的field和value：hgetall key 删除：hdel key field [field…] (可以删除多个) 列表类型 list：可以添加一个元素到列表的头部(左边)或者尾部(右边) 添加： lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取：range key start end：范围获取 获取所有：range key 0 -1 删除： lpop key：删除列表最左边的元素，并将元素返回 rpop key：删除列表最右边的元素，并将元素返回 集合类型 set 不允许重复元素 存储：sadd key value 获取：smembers key：获取set集合中所有元素 删除：srem key value：产出set集合中的某个元素 有序集合类行 sortedset：不允许重复元素，且元素有顺序 存储：zadd key score value：score为数据对应的分数，用分数对数据进行排序 获取：zrange key start end 删除：zrem key value 通用命令： keys * ：查询所有的键 type key ：获取键对应的值的类型 del key：删除指定的key value 持久化 redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中 redis持久化机制： RDB：默认机制，不需要进行配置，默认使用 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windows.conf文件 123456# 900 s(15 min)后如果至少有1个key被改变，进行持久化save 900 1# 300 s(5 min)后如果至少有10个key被改变，进行持久化save 300 10# 60 s后如果至少有10000个key被改变，进行持久化save 60 10000 重新启动redis服务器，并指定配置文件名称 12# cmd中redis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windows.conf文件 12345# 将该值设置为yes以开启AOFappendonly no# appendfsync always：每一次操作都进行持久化appendfsync everysec：每隔一秒进行一次持久化# appendfsync no：不进行持久化 重新启动redis服务器，并指定配置文件名称 12# cmd中redis-server.exe redis.windows.conf Jedis Jedis：一款java操作redis数据库的工具 使用步骤： 下载jedis的jar包 使用 12345678910@Testpublic void test1()&#123; //1. 获取连接 //如果使用空参，默认值就为"localhost", 6379 Jedis jedis = new Jedis("localhost", 6379); //2. 操作 jedis.set("username", "zhangsan"); //3. 关闭连接 jedis.close();&#125; Jedis操作redis的数据结构 1）字符串类型 string ​ set ​ get ​ 使用setex方法，指定过期时间的key value 1jedis.setex(key, seconds, value); //将key:value存入redis，并且seconds秒后自动删除 2）哈希类型 hash : map ​ hset ​ hget ​ hgetAll：返回一个Map集合 3）列表类型 list ​ lpush / rpush ​ lpop / rpop ​ lrange 4）集合类型 set ​ sadd ​ smembers 5）有序集合类型 sortedset ​ zadd Jedis连接池：JedisPool 使用： 创建JedisPool连接池对象 调用方法getResource()方法来获取连接 12345678910111213141516171819@Testpublic void test2()&#123; //0. 创建配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1. 创建连接池对象 JedisPool jedisPool = new JedisPool("localhost", 6379); //2. 获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set("1", "2"); //关闭 归还到连接池中 jedis.close(); &#125; 工具类： 1234567891011121314151617181920212223242526272829/** *JedisPool工具类 */public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); jedisPool = new JedisPool(config, pro.getProperty("host"), Integer.parseInt(pro.getProperty("post"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>JavaWeb</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX&JSON]]></title>
    <url>%2FJavaWeb-AJAX%26JSON%2F</url>
    <content type="text"><![CDATA[AJAX 概念：ASynchronous JavaScript and XML 异步的JavaScript 和 XML AJAX是一种无需刷新整个页面而更新部分页面的技术 异步和同步：客户端和服务器端相互通信的基础上 实现方式： 原生的JS实现方式 1234567891011121314151617181920212223242526272829303132333435var xmlhttp;if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125;//2.建立连接/*参数： 1.请求方式 get方式，请求参数在URL后面拼接，send方法为空参 post方式，请求参数在send方法中定义 2.请求URL路径 3.同步或异步请求*/xmlhttp.open("GET", "test1.txt", "true");//3.发送请求xmlhttp.send();//4.接收并处理来自服务器的响应结果//获取方式：xmlhttp.responseText//当服务器响应成功后获取//当xmlhttp对象的就绪状态改变时，出发时间onreadystatechangexmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.statu==200) &#123; //获取服务器的相应结果 xmlhttp.responseText; &#125;&#125; JQuery实现方式 $.ajax() 语法：$.ajax({键值对}); 123456789101112131415161718&lt;script&gt; function fun() &#123; //使用$.ajax()发送异步请求 $.ajax(&#123; url:"ajaxServlet", type:"post", //data:"username=jack",//请求参数 data:&#123;"username":"jack"&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回掉函数 error:function () &#123; //出错时执行的函数 &#125;, dataType:"text"//设置接收到响应数据的格式 &#125;); &#125;&lt;/script&gt; 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) - 参数： - url：请求路径 - data：请求参数 - callback：回调函数 - type：响应结果的类型 JSON 概念：JavaScript Object Notation JavaScript对象表示法 JSON现在多用于存储和交换文本信息，进行数据的传输 1var p = &#123;"name":"张三", "age":23, "gender":"男"&#125;; JSON比XML更小、更快、更容易解析 语法： 基本规则 数据在名称/值对中：json数据是由键值对构成的 键用引号引起来（单双都可），也可以不使用引号 取值类型 数字（整数或浮点数） 字符串（双引号中） 逻辑值（true或false） 数组（方括号中） 对象（花括号中）{“address”:{“province”:”..” …….}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{ }定义json格式 方括号保存数组：[] 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历： for in循环 12345for(var key in json对象)&#123; //key可以获取键名 //获取键值只能使用方法2，因为key是一个字符串 person[key];&#125; JSON数据和Java对象之间的转换 JSON解析器 常见：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 步骤 导入Jackson的jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json数据, Class) Java对象转为JSON 步骤： 导入Jackson的jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 1234567891011121314151617181920212223242526public class JacksonTest &#123; //Java对象转为JSON字符串 @Test public void test1() throws JsonProcessingException &#123; Person p = new Person(); p.setName("张三"); p.setAge(23); p.setGender("男"); //创建Jackson的核心对象 ObjectMapper mapper = new ObjectMapper(); //3. 转换 /* 转换方法 writeValue(参数1, obj) 参数1： File：将obj对象转换位JSON字符串，并保存到指定文件中 Writer：将obj对象转换位JSON字符串，并填充到字符输出流中 OutputStream：将obj对象转换位JSON字符串，并填充到字符输出流中 writeValueAsString(obj)：将对象转为json字符串 */ String json = mapper.writeValueAsString(p); System.out.println(json); &#125;&#125; 注解： @JsonIgnore：排除属性 @JsonFormat：属性值的格式化 复杂的java对象转换 LIst集合：数组 Map集合：对象格式一致 注意：服务器响应的数据，在客户使用时，要想当作json格式使用 $.get(type)：将最后一个参数指定为”json” 在服务器端设置MIME类型： response.setContentType(“application/json;charset=utf-8”)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb_JQuery入门]]></title>
    <url>%2FJavaWeb-JQuery%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础 概念：一个JavaScript框架，简化JS开发 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 步骤： 下载JQuery jquery-xxx.js域jquery-xxx.min.js的区别 jquery-xxx.js：用于阅读源码 jquery-xxx.min.js：用于开发中使用 在项目中导入JQuery的js文件 使用 JQuery对象和JS对象的区别与转换 JQuery对象在操作时，更加方便 JQuery对象和js对象方法不通用 相互转换 jq → js：jq对象[索引] 或者 jq对象.get(索引) js → jq：$(js对象) 选择器：筛选具有相似特征的元素(标签) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $("#b1").click(function()&#123; alert("abc"); &#125;); 2. 入口函数 $(function () &#123; &#125;); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $("#div1").css("background-color","red"); $("#div1").css("backgroundColor","pink"); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $("html标签名") 获得所有匹配标签名称的元素 2. id选择器 * 语法： $("#id的属性值") 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(".class的属性值") 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $("选择器1,选择器2....") 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $("A B ") 选择A元素内部的所有B元素 2. 子选择器 * 语法： $("A &gt; B") 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $("A[属性名]") 包含指定属性的选择器 2. 属性选择器 * 语法： $("A[属性名='值']") 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $("A[属性名='值'][]...") 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web案例_用户信息展示]]></title>
    <url>%2FJavaWeb%E6%A1%88%E4%BE%8B-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[基本功能 需求：用户信息的增删改查操作 设计： 技术：Servlet + JSP + MySQL + JDBCTemplate + Druid + BeanUtils + Tomcat 数据库设计： 1234567891011create database user_information; -- 创建数据库use user_information; -- 使用数据库create table user( id int primary key auto_increment, -- 用户编号 name varchar(32) not null, -- 用户名 gender varchar(5), -- 用户性别 age int, -- 用户年龄 address varchar(64), -- 用户住址 QQnumber varchar(32), -- 用户QQ号码 email varchar(64) -- 用户邮箱) 开发： 环境搭建 创建数据库环境 创建项目，导入需要的jar包 编码 测试 部署运维]]></content>
      <categories>
        <category>JavaWeb实践</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter和Listener]]></title>
    <url>%2FJavaWeb-Filter%26Listener%2F</url>
    <content type="text"><![CDATA[Filter：过滤器 概念 Web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的作用： 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 12345678910111213141516171819202122232425package top.wnghilin.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter; //注意导入的是Servlet包的Filterimport java.io.IOException;@WebFilter("/*")//访问所有资源之前都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("FilterDemo1......"); //放行 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 细节： web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;top.wnghilin.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下面的代码 3. 过滤器的生命周期方法 1. init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter：每一次请求被拦截资源时，会执行。执行多次 3. destroy：在服务器关闭后，Filter对象被销毁。如果服务器时正常关闭，则会执行destroy方法。只执行一次，用于释放资源 4. 过滤器配置： * 拦截路径配置 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录：/user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截：*.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 1. 注解配置 * 设置：dispacherTypes属性 * **REQUEST**：默认值。浏览器直接请求资源时，才会被执行 * **FORWARD**：转发访问资源时，才会被执行 * INCLUDE：包含访问资源 * ERROR：错误跳转资源 * ASYNC：异步访问资源 * **注意**：用{ }包含可以使用多个值 2. web.xml配置 * 设置&amp;lt;dispacher&gt;&amp;lt;/dispacher&gt; 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题 1. 注解配置：按照类名的字符串比较规则，值小的先执行 * 如：AFilter和BFilter，AFilter先执行 2. web.xml配置：&amp;lt;filter-mapping&gt;谁定义在上面，谁先执行 增强对象的功能 设计模式：一些通用的解决固定问题的方式 装饰模式 代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真是对象，达到增强真实对象功能的目的 实现方式： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 实现步骤 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance() 使用代理对象调用方法 增强方法 增强参数列表 增强返回值类型 增强方法体执行逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; public static void main(String[] args) &#123; //1.创建真实对象 Lenovo lenovo = new Lenovo(); //2.动态代理增强lenovo对象 /* 三个参数： 1. 类加载器：真实对象.getClass().getClassLoader() 2. 接口数组：真实对象.getClass().getInterfaces() 3. 处理器：new InvocationHandler() */ SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() &#123; /* 代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行 参数： 1. proxy:代理对象 2. method：代理对象调用的方法，被封装为的对象 3. args:代理对象调用的方法时，传递的实际参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /*System.out.println("该方法执行了...."); System.out.println(method.getName()); System.out.println(args[0]); */ //判断是否是sale方法 if(method.getName().equals("sale"))&#123; //1.增强参数 double money = (double) args[0]; money = money * 0.85; System.out.println("专车接你...."); //使用真实对象调用该方法 String obj = (String) method.invoke(lenovo, money); System.out.println("免费送货..."); //2.增强返回值 return obj+"_鼠标垫"; &#125;else&#123; Object obj = method.invoke(lenovo, args); return obj; &#125; &#125; &#125;); //3.调用方法 /* String computer = proxy_lenovo.sale(8000); System.out.println(computer);*/ proxy_lenovo.show(); &#125;&#125; Listener：监听器 概念：web的三大组建之一 事件监听机制： 事件：一件事情 事件源：事件发生的地方 监听器：一个对象 注册监听：将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码 ServletContexListener： 方法 void contextDestroyed(ServletContextEvent sce) void contextInitialized(ServletContextEvent sce) 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 web.xml 1234567891011 &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;top.wnghilin.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 指定初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 2. 注解：@WebListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;import java.io.FileInputStream;@WebListenerpublic class ContextLoaderListener implements ServletContextListener &#123; /** * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建。 * * 在服务器启动后自动调用 * @param servletContextEvent */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; //加载资源文件 //1.获取ServletContext对象 ServletContext servletContext = servletContextEvent.getServletContext(); //2.加载资源文件 String contextConfigLocation = servletContext.getInitParameter("contextConfigLocation"); //3.获取真实路径 String realPath = servletContext.getRealPath(contextConfigLocation); //4.加载进内存 try&#123; FileInputStream fis = new FileInputStream(realPath); System.out.println(fis); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println("ServletContext对象被创建了。。。"); &#125; /** * 在服务器关闭后，ServletContext对象被销毁。当服务器正常关闭后该方法被调用 * @param servletContextEvent */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println("ServletContext对象被销毁了。。。"); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP——Java服务器端页面]]></title>
    <url>%2FJavaWebeb-JSP%2F</url>
    <content type="text"><![CDATA[简介 概念： Java Server Pages：java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写 原理 JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的Java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么 &lt;%! 代码 % &gt;：定义的Java代码，在jsp转换后的Java类的成员位置 &lt;%= 代码 % &gt;：定义的Java代码，会输出到页面上，输出语句可以定义什么，该脚本就可以定义什么 JSP的内置对象 在JSP页面中不需要获取和创建，可以直接使用的对象 JSP一共有9个内置对象 其中3个 request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter().write和out.write()的区别 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据 response.getWriter()数据输出永远再out.write之前 深入指令 作用：用于配置JSP页面，导入资源文件 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ……&gt; 分类： page：配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的MIME类型和字符集 设置当前jsp页面的代码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding） import：导包 errorPage：当前页面发生异常后，会自动跳转到制定的错误页面 isErrorPage：指定当前页面是否是异常页面 true：可以使用内置对象exception false：默认值，不可以使用该内置对象 include：页面包含的。导入页面的资源文件 &lt;%@include file=”top.jsp” %&gt; taglib：导入资源 导入标签库：&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jst1/core“ %&gt; prefix：自定义的前缀 注释 html注释：&lt;!— — &gt;：只能注释html代码 jsp注释：推荐使用&lt;%— —%&gt;：可以注释所有 内置对象 在jsp页面中不需要创建，直接使用的对象 一共有9个： 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据 request HttpServletRequest 一次请求访问的多个资源（转发） session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面（Servlet）的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC：开发模式 如果过度使用jsp，在jsp中既写大量Java代码，又写html，造成难以维护，难以分工协作 MVC： M：Model，模型 完成具体业务操作，如：查询数据库，封装对象 V：View，视图 展示数据 C：Controller，控制器 获取用户的输入 调用模型 将数据交给视图展示 优缺点： 优点： 耦合性低，方便维护，利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中Java的编写 语法：${表达式} 注意： jsp默认是支持EL表达式的 忽略el表达式 设置jsp的page指令中：isELIgnored=”true”，忽略当前jsp页面中所有的el表达式 ${表达式}：忽略当前这个el表达式 使用： 运算： 运算符： 算数运算符：+ - * /(div) %(mod) 比较运算符：&lt; &gt; &gt;= &lt;= != == 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 空运算符：empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list} ${not empty list} 判断这些集合是否不为null并且长度大于零 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 域名称 pageScope → pageContext requestScope → request sessionScope → session applicationScope → application(ServletContext) 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示一次从最小的域中查找是否有该键对应的值，知道找到为止 获取对象、List对象、Map集合的值 对象：${域名称.键名.属性名} 本质上会调用对象的getter方法(可以自己定义新的getter方法，属性名就是getter方法去掉get再将后面的第一个字母变为小写) List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 隐式对象： el表达式中有11个隐式对象 pageContext： 获取el的其它八个内置对象 ${pageContext.request.contextPath}：动态获取虚拟目录 JSTL标签 概念：JavaServer Pages Tag Libary JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 作用：用于简化和替换jsp页面上的Java代码 使用步骤 导入jstl相关jar包 引入标签库：taglib指令：&lt;%@ taglib %&gt; 使用标签 常用JSTL标签： if：相当于java代码的if语句(没有else语句) 属性 test 必需属性 接受布尔表达式，如果为true，则显示标签体内容，若为false，则不显示 一般情况下，结合表达式一起使用 12345678910111213141516171819&lt;%@ page import="java.util.ArrayList" %&gt;&lt;%@ page import="java.util.List" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSTLDEMO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List list = new ArrayList(); list.add("a"); list.add("b"); request.setAttribute("list", list); %&gt; &lt;c:if test="$&#123;not empty list&#125;"&gt;遍历。。。&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; choose：相当于java代码的switch语句 12345678910111213141516&lt;% request.setAttribute("number", 3);%&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;number == 1&#125;"&gt;星期一&lt;/c:when&gt; &lt;c:when test="$&#123;number == 2&#125;"&gt;星期二&lt;/c:when&gt; &lt;c:when test="$&#123;number == 3&#125;"&gt;星期三&lt;/c:when&gt; &lt;c:when test="$&#123;number == 4&#125;"&gt;星期四&lt;/c:when&gt; &lt;c:when test="$&#123;number == 5&#125;"&gt;星期五&lt;/c:when&gt; &lt;c:when test="$&#123;number == 6&#125;"&gt;星期六&lt;/c:when&gt; &lt;c:when test="$&#123;number == 7&#125;"&gt;星期天&lt;/c:when&gt; &lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt; &lt;/c:choose&gt; foreach：相当于java代码的for语句 用来完成重复操作 属性： begin：开始值 end：结束值 var：临时变量 step：步长 varStatus：循环状态对象 ​ index：容器中元素的索引，从0开始 ​ count：循环次数，从1开始 1234&lt;%--输出1到10--%&gt;&lt;c:forEach begin="1" end="10" var="i" step="1"&gt; $&#123;i&#125;&lt;br&gt;&lt;/c:forEach&gt; 遍历容器 属性 items：容器对象 var：容器中元素的临时变量 varStatus：循环装阿泰对象 ​ index：容器中元素的索引，从0开始 ​ count：循环次数，从1开始 12345678910111213141516&lt;% List list = new ArrayList(); list.add("aaa"); list.add("bbb"); list.add("ccc"); list.add("ddd"); request.setAttribute("list", list);%&gt;&lt;%--输出1到10--%&gt;&lt;c:forEach begin="1" end="10" var="i" step="1" varStatus="s"&gt; $&#123;i&#125;&lt;br&gt;&lt;/c:forEach&gt; &lt;c:forEach items="$&#123;list&#125;" var="str" varStatus="s"&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125;&lt;br&gt;&lt;/c:forEach&gt; 三层架构：软件设计架构 界面层(表示层)：用户看到的界面，用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑。 数据访问层：操作数据存储文件]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会话技术——Cookie&Session]]></title>
    <url>%2FJavaWeb-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，知道有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie 概念：客户端会话技术，将数据保存到客户端的技术 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String Value) 放松Cookie对象 response.addCookie(Cookie cookie); 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节： 一次可以发送多个cookie 可以创建多个Cookie对象，使用多次response.addCookie来发送cookie即可 cookie在浏览器中保存时间 默认情况下，当浏览器关闭后，Cookie数据被清理 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。seconds代表cookie存活时间 负数：默认值 零：删除Cookie信息 cookie保存中文 tomcat 8 之前，不能直接存储中文 需要将中文数据转码 —- 一般采用url编码 tomcat 8 之后，cookie支持中文数据，对特殊字符还是不支持，建议使用url编码 cookie获取范围 默认情况下，一个tomcat服务器中部署了多个Web项目，这些项目中cookie不能共享 setPath(String path)：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，可以将path设置为”/“ 不同的tomcat服务器间cookie的共享问题 setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie可以共享 如cookie.setDomain(“.baidu.com”)，则news.baidu.com和tieba.baidu.com之间的cookie可以共享 cookie的特点： cookie存储在客户端浏览器 浏览器对于单个cookie的大小有限制(4kb左右)，以及对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存储少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次的访问时间 分析： 可以采用Cookie完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为：显示时间字符串 写回cookie 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回cookie：lastTime=时间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@WebServlet("/cookieTest")public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的消息体的数据格式以及编码 response.setContentType("text/html;charset=utf-8"); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123; for (Cookie cookie : cookies) &#123; //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if("lastTime".equals(name))&#123; //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println("解码前："+value); //URL解码： value = URLDecoder.decode(value,"utf-8"); System.out.println("解码后："+value); response.getWriter().write("&lt;h1&gt;欢迎回来，您上次访问时间为:"+value+"&lt;/h1&gt;"); //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss"); String str_date = sdf.format(date); System.out.println("编码前："+str_date); //URL编码 str_date = URLEncoder.encode(str_date,"utf-8"); System.out.println("编码后："+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); break; &#125; &#125; &#125; if(cookies == null || cookies.length == 0 || flag == false)&#123; //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss"); String str_date = sdf.format(date); System.out.println("编码前："+str_date); //URL编码 str_date = URLEncoder.encode(str_date,"utf-8"); System.out.println("编码后："+str_date); Cookie cookie = new Cookie("lastTime",str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write("&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; Session 概念：服务器端会话技术，再一次会话的多次请求间共享数据，将数据保存在服务器端 入门： 获取Session对象： HttpSession session = request.getSession() HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理： Session的实现是依赖于Cookie的 细节： 当客户端关闭后，服务器不关闭，两次获取的Session默认情况下不是同一个 如果需要相同，则可以创建Cookie，键为JSESSIONID，值设置为session.getId()，设置最大存活时间，可以长久化存储 客户端不关闭，服务器关闭，两次获取的Session一般不是同一个 要确保数据不丢失 Session的钝化： 在服务器正常关闭之前，将Session对象系列化到硬盘上 Session的火花： 在服务器启动后，将Session文件转化为内存中的Session对象即可 Session销毁时间 服务器关闭 session对象调用invaliddate() session默认失效时间 30分钟（可以在tomcat的conf/web.xml中配置session-config） 特点： session用于储存一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对不安全 案例：验证码 需求： 访问带有验证码的登录界面login.jsp 用户输入用户名，密码以及验证码 如果用户名和密码输入有误，跳转登录界面，提示：用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名，欢迎您]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2FAlgorithm-%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[简述​ 图是一种多对多形式的数据结构，线性表（一对一）、树（一对多）都可以看作特殊形式的表。 术语 顶点(Vertex)，顶点的集合一般用V表示 边(Edge)，边的集合一般用E表示 ( v, w ) ∈ E，v、w ∈ V，这种边表示 无向边 &lt; v, w &gt; ∈ E， v、w ∈ V，这种边表示 有向边 一般不考虑 重边 和 自回路 无向图：所有边都是无向边的图 有向图：所有边都是有向边的图 网络：带权重的图 邻接点：与一个顶点直接相连的点 度：与顶点连接的边的条数，有向图中又存在 入度 和 出度 连通图：在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的连通性是图的基本性质。 连通分量：无向图的极大连通子图 图的操作图的创建 邻接矩阵： 邻接矩阵是一个表示顶点相邻关系的矩阵，若两个矩阵相邻，则矩阵的对应位置值为1（若边有权重，则表示权重），否则为0 在C语言中，可用G[ N ] [ N ]来表示邻接矩阵 邻接矩阵的对角线为0，且无向图的邻接矩阵关于对角线对称 无向图的邻接矩阵可以用长度为$N(N+1)/2$的数组表示，G~ij~在该数组中的下标为$( i*(i+1)/2 + j ) $ 邻接矩阵的第 i 行的数组元素值为1的个数表示顶点i的出度，第i列的数组元素值为1表示顶点 i 的入度 优点 简单、直观、好理解 方便检查任意一对顶点之间是否存在边 方便找一个顶点的所有邻接点 方便计算任一顶点的度 缺点： 存储稀疏图时，浪费空间 浪费时间（如统计稀疏图中一共有多少边） 邻接表：G[ N ]为一个指针数组，对应矩阵每行一个链表，只保存等于1的数据 适合稀疏图使用 邻接矩阵图的创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 图的邻接矩阵表示法 */ #define MaxVertexNum 100 /* 最大顶点数设为100 */#define INFINITY 65535 /* ∞设为双字节无符号整数的最大值65535*/typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 */ /* 边的定义 */typedef struct ENode *PtrToENode;struct ENode&#123; Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */&#125;;typedef PtrToENode Edge; /* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */ DataType Data[MaxVertexNum]; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */&#125;;typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */ MGraph CreateGraph( int VertexNum )&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接矩阵 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) for (W=0; W&lt;Graph-&gt;Nv; W++) Graph-&gt;G[V][W] = INFINITY; return Graph; &#125; void InsertEdge( MGraph Graph, Edge E )&#123; /* 插入边 &lt;V1, V2&gt; */ Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; /* 若是无向图，还要插入边&lt;V2, V1&gt; */ Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;&#125; MGraph BuildGraph()&#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf("%d", &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ E = (Edge)malloc(sizeof(struct ENode)); /* 建立边结点 */ /* 读入边，格式为"起点 终点 权重"，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) &#123; scanf("%d %d %d", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); &#125; &#125; /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(" %c", &amp;(Graph-&gt;Data[V])); return Graph;&#125; 邻接表图的创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 图的邻接表表示法 */ #define MaxVertexNum 100 /* 最大顶点数设为100 */typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 */ /* 边的定义 */typedef struct ENode *PtrToENode;struct ENode&#123; Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */&#125;;typedef PtrToENode Edge; /* 邻接点的定义 */typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode&#123; Vertex AdjV; /* 邻接点下标 */ WeightType Weight; /* 边权重 */ PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */&#125;; /* 顶点表头结点的定义 */typedef struct Vnode&#123; PtrToAdjVNode FirstEdge;/* 边表头指针 */ DataType Data; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */&#125; AdjList[MaxVertexNum]; /* AdjList是邻接表类型 */ /* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ AdjList G; /* 邻接表 */&#125;;typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */ LGraph CreateGraph( int VertexNum )&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V; LGraph Graph; Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接表头指针 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) Graph-&gt;G[V].FirstEdge = NULL; return Graph; &#125; void InsertEdge( LGraph Graph, Edge E )&#123; PtrToAdjVNode NewNode; /* 插入边 &lt;V1, V2&gt; */ /* 为V2建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; /* 将V2插入V1的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; /* 若是无向图，还要插入边 &lt;V2, V1&gt; */ /* 为V1建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; /* 将V1插入V2的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125; LGraph BuildGraph()&#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf("%d", &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ /* 读入边，格式为"起点 终点 权重"，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) &#123; scanf("%d %d %d", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); &#125; &#125; /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(" %c", &amp;(Graph-&gt;G[V].Data)); return Graph;&#125; 图的遍历 深度优先搜索（Depth First Search，DFS） 深度优先沿着路径走知道不能深入为止，然后退回到某一个顶点，在选择该顶点的其他路径 由于深度优先搜索是不断深入然后退回，故其实现过程可以用堆栈来描述，所以深度优先搜索也可以用递归来实现 伪代码如下 1234567void DFS(Vertex V)&#123; visited[V] = true; for(V的每个邻接点W) if(!visited[W]) DFS(W);&#125; 广度优先搜索（Breadth First Search，BFS） 搜索一个顶点相邻的所有节点，随后继续访问相邻节点的未访问相邻节点 可以用队列来实现 伪代码如下 123456789101112void BFS(Vertex V)&#123; visited[V] = true; Enqueue(V, Q); while(!IsEmpty(Q))&#123; V = Dequeue(Q); for(V的每个邻接点W)&#123; visited[w]= true; Enqueue(W, Q); &#125; &#125;&#125; 注：每调用一次DFS或BFS，就把V所在的连通分量遍历了一遍，故对于不连通图，只需要采取以下程序来进行遍历 1234567void ListComponents(Graph G)&#123; for(each V in G) if(!visited[V])&#123; DFS[V]; &#125;&#125; 最短路径问题 分类： 单源最短路径问题 （有向）无权图 （有向）有权图 多源最短路径问题 无权图的单源最短路算法 按照递增（非递减）的顺序找出到各个顶点的最短路，与BFS类似，但略有不同 伪代码如下 1234567891011121314151617//dist[W]：S到W的最短距离，dist[s]=0, 其余可以初始化为-1、正无穷、负无穷等//path[W]：S到W的路上会经过的某点void Unweighted(Vertex S)&#123; Enqueue(S,Q); while(!IsEmpty(Q))&#123; V = Dequeue(Q); for(V的每个邻接点W)&#123; if(dist[W] = -1)&#123; dist[W] = dist[V] + 1; path[W] = V; //记录了该顶点在最短路径上的上一个点 Enqueue(W, Q); &#125; &#125; &#125;&#125;//O(V+E) 有权图的单源最短路径算法 负值圈的情况一般不进行讨论 * 思路：按照递增的顺序找出到各个顶点的最短路 * Dijkstra算法： * 令S={ 源点s + 已经确定了最短路径的顶点v~i~ } * 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径{ s→(v~i~∈S)→v }的最小长度 * 若路径是按照递增（非递减）的顺序生成的，则 * 真正的最短路必须只经过S中的顶点 * 每次从未收录的定点中选一个dist最小的收录(贪心思想) * 增加一个v进入S，可能影响另一个w的dist值(如果v的加入使得w的dist值变小，则v一定在s到w的最短路径上，且v和w必有一条边相连) * dist[w] = min{dist[w], dist[v] + 的权重} *伪代码如下* 1234567891011121314151617181920//dist[s]可初始化为0，其相邻点可初始化为它们之间边的权重，其余则初始化为正无穷void Dijkstra(Vertex s)&#123; while(1) &#123; V = 未收录定点中dist最小者; //（1） if(这样的V不存在) break; collected[V] = true; for(V的每个邻接点W) if(collected[W] == false) if(dist[V] + E&lt;V,W&gt; &lt; dist[W])&#123; dist[W] = dist[V] + E&lt;V,W&gt;; //（2） path[W] = V; &#125; &#125;&#125;//不能解决有负边的情况//该算法复杂度取决于（1）（2）步骤， * 复杂度不同的解决方法： ![](https://wnghilin-blog.oss-cn-beijing.aliyuncs.com/20190829165824.png) ### 多源最短路径算法 * 方法1：直接将单源最短路径调用|V|次 * T = O(|V|^3^+|E|×|V|)，对于稀疏图的效果号 * 方法2：Floyd算法 * T = O(|V|^3^)，对稠密图效果好 * Floyd算法 * D^k^[ i ][ j ] = 路径{i → { l ≤ k(编号小于等于k的顶点)} → j}的最小长度 * D^0^，D^1^，D^2^ ，D^3^，D^|v|-1^[ i ][ j ]即给出了 i 到 j 的正整最短距离 * D^-1^应该定义为带权的邻接矩阵，对角元为0；如果 i 和 j 之间没有直接关系，应该将D^-1^对应的值初始化为正无穷 * 当D^k-1^已经完成，递推到D^k^时： * k ∉ 最短路径{i → { l ≤ k} → j}，则D^k^ = D^k-1^ * k ∈ 最短路径{i → { l ≤ k} → j}，则D^k^[ i ][ j ] = D^k-1^[ i ][ k ] + D^k-1^[ k][ j ] 12345678910111213141516void Floyd()&#123; for(i = 0; i &lt; N; i++) for(j = 0; j &lt; N; j++) &#123; D[i][j] = G[i][j]; path[i][j] = -1; //用于记录路径 &#125; for(k = 0; k &lt; N; k++) for(i = 0; i &lt; N; i++) for(j = 0; j &lt; N; j++) if(D[i][k] + D[k][j] &gt; D[i][j])&#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125;&#125; ## 最小生成树问题 * **最小生成树（Mininum Spanning Tree）**: * 是一棵**树**： * 无回路 * |V|个顶点一定有|V-1|条边 * 是**生成树**：向生成树中任意加一条边都会构成回路 * 包含全部顶点 * |V|-1条边都在图里 * 边的权重**和**最小 ![](https://wnghilin-blog.oss-cn-beijing.aliyuncs.com/20190830173241.png) * 思想：有约束的**贪心算法** * 约束： - 只能用图里有的边 - 只能正好用掉|V|-1条边 - 不能有回路 ### Prim算法——让一棵小树长大 * 类似Dijkstra算法：Dijkstra伪代码码 * dist[V] = E(s, V) 或正无穷 * parent[s] = -1 * *Prim算法的伪代码* 1234567891011121314151617181920void Prim()&#123; MST = &#123;s&#125;; while(1) &#123; V = 未收录定点中dist最小者; if(这样的V不存在) break; 将V收录进MST中; for( V的每个邻接点W ) if( dist[W] != 0//W点未被收录 ) if( E(V,W) &lt; dist[W] ) &#123; dist[W] = E(V,W); parent[W] = V; &#125; &#125; if(MST中收到的点不到|V|个) Error("生成树不存在");&#125; 适合稠密图 Kruskal算法——将森林合并成树 直接按递增顺序选出图中权重最小的边（但不能与已选中的边构成回路） 伪代码如下： 123456789101112131415void Kruskal(Graph G)&#123; MST = &#123; &#125;; while(MST中步到|V|-1条边 &amp;&amp; E中还有边) &#123; 从E中取一条权重最小的边E(V,W); /*最小堆*/ 将E(V,W)从E中删除; if(E(V,W)不在MST中构成回路) /*并查集*/ 将E(V,W)加入MST; else 彻底无视E(V,W); &#125; if(MST中不到|V|-1条边) Error("生成树不存在");&#125;]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet-运行在服务器端的小程序]]></title>
    <url>%2FJavaWeb-Servlet%2F</url>
    <content type="text"><![CDATA[Servlet概述 概念：运行在服务器端的小程序 server applet Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则 使用 创建JavaEE项目 1public class ServletDemo1 implements Servlet 定义一个类，实现Servlet接口 实现接口中的抽象方法 配置在Servlet 12345678910&lt;!--配置Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;top.wnghilin.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容 如果有，则再找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet中的生命周期： 被创建：执行init方法，只执行一次 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;servlet-class&gt;top.wnghilin.servlet.ServletDemo2&lt;/servlet-class&gt; &lt;!--指定Servlet创建时机 1.第一次被访问时，创建，默认值是-1 &lt;load-on-startup&gt;的值为负数 2.服务器启动时，创建 &lt;load-on-startup&gt;的值为0或正整数 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 * 多个用户同时访问时，可能存在线程安全问题 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值 提供服务：执行service方法，执行多次 每次访问Servlet时，Servlet方法都会被调用一次 被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁。 只有服务器正常关闭时，才会执行destroy方法 destroy方法在Servlet被销毁之前执行，一般用于释放资源 使用Servlet3.0 好处： 支持注解配置。可以不用web.xml 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 1@WebServlet("资源路径") 123456789101112131415161718192021222324252627//WebServlet定义package javax.servlet.annotation;@java.lang.annotation.Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)@java.lang.annotation.Documentedpublic @interface WebServlet &#123; java.lang.String name() default ""; java.lang.String[] value() default &#123;&#125;; java.lang.String[] urlPatterns() default &#123;&#125;; int loadOnStartup() default -1; javax.servlet.annotation.WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; java.lang.String smallIcon() default ""; java.lang.String largeIcon() default ""; java.lang.String description() default ""; java.lang.String displayName() default "";&#125; IDEA会为每一个tomcat部署的项目单独简历一份配置文件 查看控制台的log：Using CATALINA_BASE: “C:\Users\Nier.IntelliJIdea2019.2\system\tomcat\Tomcat_8_5_31_Tomcat_2” 工作空间项目 和 tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”，“tomcat部署的web项目”对应着“工作空间项目”的文本目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问 Servlet详解 Servlet的体系结构 Servlet — 接口 ​ | GenericServlet — 抽象类 ​ | HttpServlet — 抽象类 GenericServlet: 将Servlet接口中其他的方法做了默认空实现，只有service方法作为抽象 定义Servlet类是，可以继承GenericServlet，实现service()方法即可 HttpServlet：对HTTP协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost Servlet相关配置： urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径 路径定义规则 /xxx：路径匹配 /xxx/xxx：多层路径，目录结构 *.do：扩展名匹配 请求消息：客户端发送给服务器端的数据 数据格式： 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html * 告诉服务器，当前请求从哪里来 * 作用： 1. 防盗链： 2. 统计工作： 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)： 封装POST请求消息的请求参数的 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/2010010 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 响应消息：服务器端发送给客户端的数据 数据格式 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 状态码都是3位数字 分类： 1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码 2xx：成功。代表：200 3xx：重定向。代表：302（重定向），304（访问缓存） 4xx：客户端错误。 代表： 404：请求路径没有对应的资源 405：请求方式没有对应的doXXX方法 5xx：服务器端错误，代表：500（服务器内部出现异常） 响应头 格式：头名称: 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 值： in-line：默认值，在当前页面打开 attachment; filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体：传输的数据 响应字符串格式： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;response&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello, response &lt;/body&gt;&lt;/html&gt; request和response对象 原理： request和response对象是由服务器创建的，我们来使用它们 request对象用来获取请求消息，response对象用来设置响应消息 request对象继承体系结构： ServletRequest — 接口 | 继承 HttpServletRequest — 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) request 获取请求消息数据 获取请求行数据 GET /servletdemo/demo1/?name=zhangsan HTTP/1.1 方法： 获取请求方式：GET String getMethod() （*）获取虚拟目录：/servletdemo String getContextPath() 获取Servlet路径：/demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQuery() （*）获取请求URI：/servletdemo/demo1 String getRequestURI()：返回/servletdemo/demo1 StringBuffer getRequestUrl()：返回http://localhost/servletdemo/demo1 URL：统一资源定位符 URI：统一资源标识符 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址 String getRemoteAddr() 获取请求头数据 方法： （*）String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames()：获取所有的请求头名称 获取请求体数据 只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节数据输入流，可以操作所有类型数据 再从流对象中拿数据 123456789101112131415161718@WebServlet("/requestDemo5")public class RequestDemo5 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求消息体--请求参数 //1.获取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 其他功能： 获取请求参数通用方式：get和珀斯特请求方式都可以使用下列方式来获取请求参数 String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组（多用于复选框） Enumeration&lt;String&gt; getParameterNames()：获取所有请求的参数名称 Map&lt;String, String[]&gt; getParameterMap()：获取所有参数的map集合 中文乱码问题： get方式：tomcat8已经将乱码问题解决 post方式：会乱码 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(“utr-8”); 请求转发：一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用该对象进行转发: forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求，可以使用request对象共享数据 对比：重定向的特点 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： setAttribute(String name, Object obj)：存储数据 getAttribute(String name)：通过键获取值 removeAttribute(String name)：通过键移除值对 获取ServletContext对象： ServletContext getServletContext() response 功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 OK 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体 使用步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 案例： 完成重定向 12345678910111213141516171819202122/** * 重定向 */@WebServlet("/responseDemo1")public class ResponseDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("demo1..."); //访问这个资源会自动跳转到/responseDemo2资源 //1. 设置状态码为302 response.setStatus(302); //2. 设置响应头location response.setHeader("location", "/Response/responseDemo2"); //简单的重定向方法 response.sendRedirect("/Response/responseDemo2"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 重定向的特点： 地址栏发生变化 重定向可以访问其他站点（服务器）的资源 重定向是两次请求，不能用request对象共享数据 对比：转发的特点 路径的写法： 相对路径：通过相对路径不可以确定唯一资源 如：./index.html（ ./ 可以省略） 不以 / 开头，以 . 开头 规则：确定访问当前资源和目标资源之间的相对位置关系 ./：当前目录 ../：后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 如：http://locahost/day15/responseDemo2 /day15/responseDemo2 以 / 开头的路径 规则：判断定义路径是给谁用的 给客户端浏览器使用：需要加虚拟目录（项目的访问路径） 最好动态获取虚拟目录：request.getContextPath &lt;a&gt;, &lt;form&gt;, 重定向 给服务器使用：不需要加虚拟目录 转发路径 服务器输出字符数据到浏览器：注意编码 步骤 获取字符输出流 输出数据 123456789101112131415protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取流对象之前，设置流的默认编码，ISO-8859-1设置为：GBK response.setCharacterEncoding("utf-8"); //告诉浏览器，服务器发送的消息体数据的编码，建议浏览器使用该编码解码 response.setHeader("content-type", "text/html; charset=utf-8"); //简单形式设置编码 response.setContentType("text/html;charset=utf-8"); //1.获取字符输出流 PrintWriter pw = response.getWriter(); //2.输出数据 pw.write("&lt;h1&gt;Hello response&lt;/h1&gt;");&#125; 服务器输出字节数据到浏览器 步骤： 获取字节输出流 输出数据 验证码 本质：图片 目的：防止恶意表单注册 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@WebServlet("/checkCodeServlet")public class CheckCodeServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789"; //生成随机角标 Random ran = new Random(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 //2.3写验证码 g.drawString(ch+"",width/5*i,height/2); &#125; //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //3.将图片输出到页面展示 ImageIO.write(image,"jpg",response.getOutputStream()); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; /* 分析： 点击超链接或者图片，换一张图片 1.给超链接和图片绑定单击事件 2.重新设置图片的src属性值 */ window.onload = function()&#123; //1.获取图片对象 var img = document.getElementById("checkCode"); //2.绑定单击事件 img.onclick = function()&#123; //加时间戳 var date = new Date().getTime(); img.src = "/day15/checkCodeServlet?"+date; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id="checkCode" src="/day15/checkCodeServlet" /&gt; &lt;a id="change" href=""&gt;看不清换一张？&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 案例： 文件下载： 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析： 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 任何资源都必须弹出下载提示框 使用响应头设置资源的打开方式 content-disposition：attachment;filename=xxx 步骤： 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头：content-disposition: attachment;filename=xxx 将数据写出到response输出流 html页面 123&lt;a href="/Response/img/1.png"&gt;图片1&lt;/a&gt;&lt;hr&gt;&lt;a href="/Response//downloadServlet?filename=1.png"&gt;图片1&lt;/a&gt; Servlet代码 1234567891011121314151617181920212223242526272829303132333435@WebServlet("/downloadServlet")public class DownloadServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求餐宿和，文件名称 String filename = request.getParameter("filename"); //2.使用字节输入流加载文件进内存 //2.1找到文件的服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath("/img/" + filename); //2.2用字节流关联 FileInputStream fis = new FileInputStream(realPath); //设置response的响应头 //3.1设置响应头类型 content-type //获取文件MIME类型 String mimeType = servletContext.getMimeType(filename); response.setHeader("content-type", mimeType); //3.2设置响应头打开方式 content-disposition response.setHeader("content-disposition","attachment;filename="+filename); //4.将输入流的数据写出到输出流中 ServletOutputStream outputStream = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while((len = fis.read(buff)) != -1)&#123; outputStream.write(buff,0,len); &#125; fis.close(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 中文文件名问题： 解决思路： 获取客户端使用的浏览器版本信息 根据不同的浏览器信息进行编码处理，工具类可以从网上下载 工具类示例 1234567891011121314151617181920212223import sun.misc.BASE64Encoder;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;public class DownLoadUtils &#123; public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains("MSIE")) &#123; // IE浏览器 filename = URLEncoder.encode(filename, "utf-8"); filename = filename.replace("+", " "); &#125; else if (agent.contains("Firefox")) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?="; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, "utf-8"); &#125; return filename; &#125;&#125; BeanUtils工具类 用于封装JavaBean JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 概念：属性：setter和getter后截取的产物 如成员变量为user，setter为setUser，则User为属性（若setter为setHehe，则Hehe为属性，与user无关，只与setter有关） 方法： setProperty()：操作的是属性，不是成员变量 getProperty() populate(Object obj，Map map)：将map集合的键值对信息，封装到对应的JavaBean对象中 ServletContext对象 概念：代表整个web应用，可以和程序的容器（服务器）来通信 获取： 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext(); 功能： 获取MIME类型 MIME类型：在互联网通信过程中顶一顶一种文件数据类型 格式：大类型/小类型 text/html image/jpeg 获取：String getMimeType(String file) 域对象：共享数据 setAttribute(String name, Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 获取文件的真实（服务器）路径 方法：String getRealPath(String path) 1234567891011121314 // 通过HttpServlet获取 ServletContext context = this.getServletContext(); // 获取文件的服务器路径 String b = context.getRealPath("/b.txt");//web目录下资源访问 System.out.println(b);// File file = new File(realPath); String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问 System.out.println(a);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>服务器</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务器软件：Tomcat]]></title>
    <url>%2FJavaWeb-Tomcat%2F</url>
    <content type="text"><![CDATA[Web相关概念 软件架构 C/S：客户端/服务器端 B/S：浏览器/服务器端 资源分类 静态资源：所有用户访问后，得到的结果都一样，静态资源可以直接被浏览器解析 如：html，css，JavaScript 动态资源：每一个用户访问相同资源后得到的结果可能不一样。动态资源被访问后，需要先转换为静态资源，再返回给浏览器 如：servlet/jsp，php，asp… 网络通信三要素 IP：电子设备在网络中的唯一标识 端口：应用程序在计算机中的唯一标识。0~65536 传输协议：规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。速度稍慢 udp：不安全协议。速度快 Web服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户请求，处理请求，做出响应 web服务器软件：接收用户请求，处理请求，做出响应 在Web服务器软件中，可以部署web项目，让用户通过浏览器来访问 web容器 常见的java相关的Web服务器软件： webLogic：Oracle公司，大型JavaEE服务器，支持所有JavaEE规范，收费。 webSphere：IBM公司，大型JavaEE服务器，支持所有JavaEE规范，收费。 JBOSS：JBOSS公司，大型JavaEE服务器，支持所有JavaEE规范，收费。 Tomcat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量JavaEE规范，开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat 下载：http://tomcat.apache.org/ 安装：解压压缩包即可 注意：安装目录建议不要有中文 卸载：删除目录即可 启动 可能遇到的问题： 黑窗口一闪而过： 原因：没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量即可（在环境变量中新建JAVA_HOME环境变量，再将path中的jdk路径修改为%JAVA_HOME%\bin） 启动报错 暴力：找到占用的端口号，并找到对应的进程，杀死该进程 netstat -ano：在列表中找到对应端口号的PID 使任务管理器显示PID win7：任务管理器—&gt;查看—&gt;选择列—&gt;勾选PID win10：在名称栏处右键，勾选PID 关闭相应进程 温柔：修改自身端口号 安装目录/conf/server.xml，编辑该文件 注意该文件中的其他端口号也要改，如redirectPort等 一般会将tomcat的默认端口号修改为80。80端口是http协议的默认端口号，访问时可以不用输入端口号 关闭 正常关闭： bin\shutdown.bat 在启动窗口按ctrl+c 强制关闭： 点击启动窗口的× 配置 部署项目的方式： 直接将项目放到webapps文件夹下即可（localhost\项目名称\资源文件 可以直接访问） \项目名称：项目的访问路径—&gt;虚拟目录 简化方式：将项目打包成一个war包，再将war包放置在webapps目录下。 在webapps目录下，war包会自动解压 可以通过将项目压缩为zip文件再改后缀名得到war包，也可通过专门的war打包软件获得 /conf/server.xml文件的Host标签提中添加配置 在\conf\Catalina\localhost文件夹下新建deploy.xml（名字随意），添加如下内容 1&lt;Context docBase="D:\hello" /&gt; 此时的虚拟目录：xml文件的名称 静态项目和动态项目 目录结构 静态项目放置静态资源 java动态项目的目录结构： — 项目的根目录 ​ — WEB-INF目录： ​ — web.xml：web项目的核心配置文件 ​ — classes目录：防止字节码文件的目录 ​ — lib目录：防止依赖的jar包 Tomcat集成到IDEA中 打开IDEA Run—&gt;Edit Configurations 选择Template—&gt;Tomcat Server—&gt;Local—&gt;Configure.. 选择自己的Tomcat目录 完成配置 创建JavaWeb项目]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>服务器</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML入门]]></title>
    <url>%2FJavaWeb-XML%2F</url>
    <content type="text"><![CDATA[XML简介 概念：Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的 功能： 存储数据： 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义，html标签时预定义 xml语法严格，html语法松散 xml是存储数据的，html是展示数据的 w3c：万维网联盟 语法 基本语法： 文档后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号引起来（单双都可） 标签必须正确关闭 xml标签名称区分大小写 组成部分： 文档声明 格式：&lt;?xml$ 属性列表 ?&gt; 属性列表： version：版本号，必需的属性 encoding：编码方式，告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值 yes：不依赖其他文件 no：依赖其他文件 指令（了解）：结合css 1&lt;? xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签：标签名称自定义 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 属性： id属性值唯一 文本 CDATA区：该区域内的数据会被原样展示 格式：&lt;![CDATA[数据]]&gt; 约束 概念：规定xml文档的书写规则 在xml中引入约束文档 读懂约束文档 分类： DTD：一种简单的约束技术 Schema：一种复杂的约束技术 DTD 引入dtd文档到xml文档中： 内部dtd：将约束规则定义在xml文档中（较少使用） 12345678&lt;!DOCTYPE students [ &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt; 外部dtd：将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt; Schema 引入过程 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance“ 引入xsd文件命名空间. xsi:schemaLocation=”命名空间url 文件名.xsd” 为每一个xsd约束声明一个前缀,作为标识 xmlns:前缀=”命名空间” 解析 概念：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取当内存中 写入：将内存中的数据保存到xml文档中 解析xml方式： DOM：将标记语言文档一次性加载进内存，形成一棵DOM树 优点：操作方便，可以对文件进行CRUD所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动 优点：不占内存 缺点：只能读取，不能增删改 xml常见解析器： JAXP：Sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android内置的解析器，sax方式 Jsoup解析器 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 示例 1234567891011121314151617public class jsoupDemo1 &#123; public static void main(String[] args) throws IOException &#123; //2.获取Document对象，根据xml文档获取 //2.1获取student.xml的path String path = jsoupDemo1.class.getClassLoader().getResource("student.xml").getPath(); //2.2解析xml文档，加载进内训，获取dom树 Document document = Jsoup.parse(new File(path), "utf-8"); //3.获取元素对象 Element对象 Elements elements = document.getElementsByTag("name"); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); &#125;&#125; 对象的使用： Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件 parse(String html)：解析xml或html字符串，参数为html或xml代码 parse(URL url, int timeoutMillis)：通过网络路径获取指定的文档对象 1URL url = new URL("https://网址"); Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的元素对象 getElementsByTag(String TagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值来获取元素对象 Elements：元素Element对象的a’t’h集合。可以当作ArrayList&lt;Elements&gt;来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的元素对象 getElementsByTag(String TagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值来获取元素对象 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text()：获取文本内容 String html()：获取标签体的所有内容（包括子标签的字符串内容） Node：节点对象 是Document和Element的父类 快捷查询方式： selector：选择器 方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。 使用Jsoup的Xpath需要额外导入jar包 12345//3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询（具体查看文档） List&lt;JXNode&gt; jxNodes = jxDocument.selN("//student");]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发框架——Bootstrap]]></title>
    <url>%2FJavaWeb-Bootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap简介 好处 Bootstrap定义了很多css样式和js插件，可以提供极为丰富的页面效果 响应式布局。 同一套页面可以兼容不同分辨率的设备 使用 下载Bootstra https://v3.bootcss.com/ 将3个文件夹复制进项目 创建html页面，引入必要的资源文件，以下为基本模板（去掉了兼容ie8的设置） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局 同一套页面可以建中不同分辨率的设备 实现：依赖于栅格系统 栅格系统：将一行平均分为12个格子，可以指定元素占几个格子 步骤： 定义容器。相当于table 分类： container：两边留白 container-fluid：每种设备都占满100%宽度 定义行。相当于tr 样式：row 定义元素。指定该元素在不同的设备上所占的格子的数目 样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机( &lt;768px ) sm：小屏幕 平板( ≥768px ) md：中等屏幕 桌面显示器( ≥1200px ) lg：大屏幕 大桌面显示器( 大于等于1200px ) 12345678910111213141516171819202122&lt;!-- 1.定义容器 --&gt; &lt;div class="container-fluid"&gt; &lt;!-- 2.定义行 --&gt; &lt;div class="row"&gt; &lt;!-- 3.定义元素 大显示器一行12个格子 pad上一行6个格子 --&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2"&gt;栅格&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 注： 一行中格子数目超过12，超出部分自动换行 栅格类属性可以向上兼容（适用于与屏幕宽度大于或等于分界点大小的设备） 如果设备宽度小于设置栅格类属性设备代码的最小值，会一个元素占满一整行 CSS样式和JS插件CSS样式 全局CSS样式 按钮：官方文档 设置默认按钮：官方文档 1234&lt;a class="btn btn-default" href="#" role="button"&gt;Link&lt;/a&gt;&lt;button class="btn btn-default" type="submit"&gt;Button&lt;/button&gt;&lt;input class="btn btn-default" type="button" value="Input"&gt;&lt;input class="btn btn-default" type="submit" value="Submit"&gt; 设置按钮样式: 官方文档 1234567&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt; 设置按钮尺寸：官方文档 1234&lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt; 图片 图片在任意尺寸都占100% 1&lt;img src="..." class="img-responsive" alt="Responsive image"&gt; 图片的形状 123456&lt;!--方形--&gt;&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;!--圆形--&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;!--相框--&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt; 表格：官方文档 123&lt;table class="table table-bordered table-hover"&gt; ... &lt;/table&gt; 表单：官方文档 可以给表单项添加：class=”form-control”(所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;) 123456789101112131415161718192021&lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 组件： 导航条 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 分页条 12345678910111213141516171819&lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; JS插件 轮播图：官方文档]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>前端</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池与JDBC Template]]></title>
    <url>%2FJavaWeb_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8EJDBC-Template%2F</url>
    <content type="text"><![CDATA[数据库连接池 概念：一个容器（集合），用来存放数据库连接。当系统初始化好后，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器 优势: 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：如果连接对象Conection是从连接池中获取，调用Connection.close()，则不会再关闭连接，而是归还连接 由数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供 C3P0 步骤： 导入jar包：c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar（不能忘记导入数据库驱动jar包） 定义配置文件 名称：c3p0.properties 或 c3p0-config.xml 路径：直接将文件放在src目录下即可 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接：getConnection 1234//1.创建数据库连接池DataSource ds = new ComboPooledDataSource();//2.获取连接对象sConnection conn = ds.getConnection(); Druid 步骤： 导入jar包：druid-1.0.9.jar(和数据库驱动jar包) 定义配置文件 properties形式 可以叫任意名称，可以放在任意目录下 加载配置文件.properties 获取数据库连接池对象：通过工厂类来获取 DruidDataSourceFactory 获取连接：getConnection 示例1234567891011121314151617181920212223import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;/** * Druid演示 */public class DruidDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.导入jar包 //2.配置文件 //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream("druid.properties"); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 定义工具类 定义一个类 JDBCUtils 提供方法： 获取连接方法：通过数据库连接池获取连接 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Druid连接池的工具类 */public class JDBCUtils &#123; //定义成员变量Datasource private static DataSource ds; static&#123; try &#123; //加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //获取Datasource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException&#123; return ds.getConnection(); &#125; /** * 释放资源，此处close为归还连接池 */ public static void close(Statement stmt, Connection conn)&#123;略，同上&#125; /** * 释放资源 */ public static void close(ResultSet rs, DataStatement stmt, Connection conn)&#123;略，同上&#125; /** * 获取连接池 */ public static DataSource getDataSourse()&#123; return ds; &#125;&#125; Spring JDBC Spring框架对JDBC的简单封装。提供JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 创建JdbcTemplate对象。依赖于数据源的DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法完成CRUD操作 update()：执行DML语句 queryForMap()：查询结果，将结果封装为map集合 查询的结果集长度只能是1，即只能查找一条结果 queryForList()：查询结果，将结果封装为list集合 将每一条记录封装成map集合，再将这些map封装成list集合 query()：查询结果，将结果封装为JavaBean对象 参数：RowMapper 一般使用BeanPropertyRowMapper，见下方实例 queryForObject()：查询结果，将结果封装为对象 update方法示例： 12345678910public class JDBCTemplateDemo1 &#123; public static void main(String[] args) &#123; //创建JdbcTemplate对象 JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSourse()); //调用方法 String sql = "update account set balance = 5000 where id = ?"; int count = template.update(sql, 3);//将?的值设置为3 System.out.println(count); &#125;&#125; query方法示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class JDBCTemplateDemo2 &#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSourse()); /** * 测试query()方法,自写RowMapper实现类 */ @Test public void test1()&#123; String sql = "select * from account"; List&lt;Account&gt; accounts = template.query(sql, new RowMapper&lt;Account&gt;() &#123; @Override public Account mapRow(ResultSet rs, int i) throws SQLException &#123; Account ac = new Account(); int id = rs.getInt("id"); int balance = rs.getInt("balance"); String name = rs.getString("name"); ac.setBalance(balance); ac.setName(name); ac.setId(id); return ac; &#125; &#125;); System.out.println(accounts); &#125; /** * 调用写好的BeanProperRowMapper类 */ @Test public void test2()&#123; String sql = "select * from account"; List&lt;Account&gt; accounts = template.query(sql, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); System.out.println(accounts); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>数据库</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-在Java中操作数据库]]></title>
    <url>%2FJavaWeb-JDBC%2F</url>
    <content type="text"><![CDATA[JDBC基础 概念：Java Database Connectivity Java数据库连接 本质：官方定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商实现这套接口，提供数据库驱动 jar 包，可以使用（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门： 步骤： 导入驱动jar包 mysql-connector-java-版本号-bin.jar 复制到mysql-connector-java-版本号-bin.jar到项目的libs目录下 右键 —&gt; Add As Libary 注册驱动 获取数据库的连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 1234567891011121314151617181920public class JDBCdemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.导入驱动jar包 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db2", "用户名", "密码"); //4.定义sql语句 String sql = "sql语句"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); &#125;&#125; 详解各个对象DriverManager：驱动管理对象 功能： 注册驱动：该执行哪一个jar包 static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(“com.mysql.jdbc.Driver”); 在com.mysql.jdbc.Driver类中存在静态代码块，该代码的内容为调用registerDriver方法，所以方法2较为方便。 注：mysql5之后的驱动jar包可以省略注册驱动的步骤 获取数据库连接 方法：static Connection getConnection(String url, String user, String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 如果连接的是本机的mysql服务器，并且mysql服务器默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection：数据库连接对象 功能： 获取执行sql的对象： Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务： 开启事务：void setAutoCommit(boolean autoCommit) 调用该方法，设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql)：可以执行任意sql语句（了解） int executeUpdate(String sql)：执行DML语句、DDL语句 返回值：影响的行数，通过影响的行数判断执行是否成功(若大于 0 则执行成功)，创建表返回值为0 ResultSet executeQuery(String sql)：执行DQL(select)语句 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JDBCdemo2 &#123; public static void main(String[] args) &#123; Statement stmt = null; Connection conn = null; try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL String sql = "insert into account values(null, 'wangwu', 3000)"; //3.获取Connection对象 conn = DriverManager.getConnection("jdbc:mysql:///db2", "root", "wnghilin"); //4.获取Statement对象 stmt = conn.createStatement(); //5.执行Sql int count = stmt.executeUpdate(sql); //影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println("添加成功"); &#125; else&#123; System.out.println("添加失败"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; //7.释放资源 //注意避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; ResultSet：结果集对象 功能：封装查找结果 next()：游标向下移动一行(游标最开始指向如图所示位置) getXxx(参数)：获取数据 Xxx：代表数据 如：int getInt(), String getString() 参数： int：代表列的编号，如：getString(1)，获取第一列，不是从0开始 String：代表列的名称，如：getInt(“id”) 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.*;public class JDBCdemo3 &#123; public static void main(String[] args) &#123; Statement stmt = null; Connection conn = null; ResultSet result = null; try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL String sql = "select * from account"; //3.获取Connection对象 conn = DriverManager.getConnection("jdbc:mysql:///db2", "root", "wnghilin"); //4.获取Statement对象 stmt = conn.createStatement(); //5.执行Sql result = stmt.executeQuery(sql); //6.处理结果 //6.1让游标向下移动一行 result.next(); //6.2获取数据 int id = result.getInt("id"); String name = result.getString("name"); double balance = result.getDouble(3); System.out.println(id + "---" + name + "---" + balance); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 //注意避免空指针异常 if (result != null) &#123; try &#123; result.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全问题 输入用户随便，输入密码a’ or ‘a’ = ‘a sql: select * from user where username = ‘随便’ and password = ‘a’ or ‘a’ = ‘a’ 一定返回true 解决：使用PreparedStatement 预编译的SQL：参数使用?作为占位符 步骤 导入驱动jar包 mysql-connector-java-版本号-bin.jar 注册驱动 获取数据库的连接对象 Connection 定义sql 注意：sql参数使用?作为占位符，如select * from user where username=? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给?赋值 方法：setXxx(参数1, 参数2) 参数1：?的位置，从1开始 参数2：?的值 执行sql，接受返回结果，不需要再传递sql语句 处理结果 释放资源 优势： 可以防止SQL注入 效率更高 抽取JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动抽取 抽取方法获取连接对象 不传递参数，但需要保证类的通用性 解决方案：配置文件 抽取方法释放资源 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.File;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;/** * JDBC工具类 */public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次就可以拿到这些值 */ static&#123; //读取资源文件，获取值 try &#123; //1.创建Properties集合类 Properties pro = new Properties(); //获取src路径下的文件的方式:ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource("jdbc.properties"); String path = res.getPath(); //2.加载文件 pro.load(new FileReader(path)); //3.获取数据，赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection()&#123; return null; &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn)&#123; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 释放资源 * @param rs * @param stmt * @param conn */ public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>数据库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL简要学习]]></title>
    <url>%2FJavaWeb_MySQL%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库(database)： 用于存储和管理数据的仓库 特点： 持久化存储数据（数据库就是一个文件系统） 方便存储和管理数据 使用同意的方式操作数据库 —- SQL 数据库软件：Oracle、MySQL、Microsoft SQL Server、DB2 MySQL配置 服务启动： net start mysql：需要管理员权限 services.msc 登录： mysql -uroot -p自己的密码(mysql -uroot -p也可) mysql -hip -uroot -p链接目标的密码（ip替换为目标的ip地址） mysql —host=ip —user=root —password=root 退出： exit quit 目录结构 安装目录 配置文件：my.ini 数据目录 数据库：文件夹 表：文件 数据：文件中储存的数据 SQL基本概念 Struct Query Language：结构化查询语言 操作所有关系型数据库的规则 每一种数据库操作方式存在不一样的地方，称为“方言” 通用语法 SQL语句可以单行或多行书写，以分号结尾 使用空格和缩进增强语句可读性 MySQL的SQL语句不区分大小写，但关键字建议用大写 3种注释： 单行注释：— 注释内容或 # 注释内容（注意空格） 多行注释：/ 注释 / 分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL：操作数据库、表 操作数据库：CRUD C(Create)：创建 创建数据库 create database 数据库名; create database if not exists 数据库名;— 如果数据库不存在，则创建数据库 create database 数据库名 character set 字符集名;— 手动指定字符集 12-- 创建db4并且将其字符集设置为gbkcreate if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称： show databases; 查看某个数据库的字符集，查询某个数据库的创建语句 show create database 数据库名称; U(Update)：修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete)：删除 删除数据库 drop database 数据库名称; drop database if exisits 数据库名称; — 判断数据库是否存在 慎用 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作表：CRUD C(Create)：创建 数据类型： int：整数类型 age int; double：小数类型 score double(5, 2); — 一共5位，保留两位小数 date：日期，只包含年月日，yyyy-MM-dd datetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss timestamp：事件错类型，包含年月日时分秒，yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间自动赋值 varchar：字符串类型 name varchar(20); — 姓名最大20个字符 zhangsan 8个字符， 张三 2个字符 创建表 1234567create table 表名( 列名1 数据类型1, 列名2 数据类型2, ...... 列名n 数据类型n)-- 注意最后一列不用加逗号(,) 复制表：create table 表名 like 被复制表名; R(Retrieve)：查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update)：修改 修改表名 alter table 表名 rename to 新的表名; 修改字符集 show create table 表名;— 查看表的字符集 alter table 表名 character set 字符集; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete)：删除 drop table if exists 表名; drop table 表名; DML：增删改标中数据 添加数据 语法： insert into 表名(列名1, 列名2, …… 列名n) values(值1, 值2, …… 值n); 注意： 列名和值应该一一对应 如果表名后，不定义列名，则默认给所有列添加值 1INEINSERT INTO stu VALUES(2,'秀吉',18,99.2,'2000-08-23',NULL,"秀吉"); 出了数字类型，其他类型需要’ ‘或” “引起来 删除数据 语法： delete from 表名 [where 条件]; 1DELETE FROM stu WHERE id=1; 注意： 如果不加条件，则删除表中所有记录 truncate table 表名; — 删除表，再创建一个一模一样的空表，建议用这种方式删除全部记录 delete from 表名; — 执行次数为记录条数，效率较低 修改数据 语法： update 表名 set 列名1 = 值1, 列名2 = 值2, … [where 条件]; 注意 如果不加条件，则修改表中所有数据 DQL：查询表中的记录 语法： 1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序limit 分页限定 基础查询 多个字段的查询 select 字段名1, 字段名2… from 表名; 可用*来替代所有字段 去除重复 12-- 去除重复的结果集SELECT DISTINCT address FROM student; 计算列 12345-- 计算math和english两列的和-- 如果有null参加运算，则结果仍为nullSELECT NAME, math, english, math + english FROM student3;-- 将NULL替换为0SELECT NAME, math, IFNULL(english), math + english FROM student3; 起别名 123SELECT NAME, math, english, math + english AS 总分 FROM student3;-- 简化形式SELECT NAME, math 数学, english 英语, math + english 总分 FROM student3; 条件查询 where后跟条件 运算符 “&gt;”, “&lt;”, “&lt;=”, “&gt;=”, “=”, “&lt;&gt;” BETWEEN…AND IN（集合） LIKE 占位符： _：单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! 123456-- 查询年龄在20到30之间的（包含20和30）SELECT * FROM student3 WHERE age BETWEEN 20 AND 30;-- 查询英语成绩为空SELECT * FROM student3 WHERE english IS NULL;-- 查询英语成绩不为空SELECT * FROM student3 WHERE english IS NOT NULL; 模糊查询 123456-- 查询所有姓王的同学SELECT * FROM student3 WHERE name LIKE '王%';-- 查询名字有三个字的人SELECT * FROM student3 WHERE NAME LIKE '___';-- 查询姓名中有“国”字的人SELECT * FROM student3 WHERE NAME LIKE '%国%'; 排序查询 语法： order by 排序字段1 排序方式1, 排序字段2 排序方式2, …; 先按字段1排序，如有相同，按字段2排序，以此类推。 排序方式 ASC：升序，默认 DESC：降序 1SELECT * FROM stu ORDER BY math ASC, english DESC; 聚合函数：将一列数据作为一个整体，进行纵向的计算。 count：计算个数 max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注：所有聚合函数会排除为NULL的数据 1SELECT AVG(math) FROM student; 排除NULL的解决方案 12SELECT COUNT(IFNULL(english,0)) FROM student;-- 把NULL替换成0，以便统计人数等（不会修改原数据）-- 或选择非空的列进行计算 分组查询： 语法：group by 分组字段; 12345-- 按照性别分组，并分别求数学的平均分SELECT sex, AVG(math) FROM student GROUP BY sex;-- 加入分组限定条件SELECT sex, AVG(math), COUNT(id) FROM student WHERE math &gt; 60 GROUP BY sex;SELECT sex, AVG(math), COUNT(id) FROM student WHERE math &gt; 60 GROUP BY sex HAVING COUNT(id)&gt;1; 注意： 分组之后查询的字段：分组字段，聚合函数 where 和 having的区别 where在分组前限定，如不满足条件，则不参与分组；having在分组后进行限定，如果不满足结果，则不会被查询出来。 where后不可以跟聚合函数，having可以 分页查询： 语法：limit 开始的索引, 每页查询的条数; 开始的索引 = （当前的页码 - 1） * 每页显示的条数 123-- 每一页显示3条记录SELECT * FROM student LIMIT 0,3; -- 第一页SELECT * FROM student LIMIT 3,3; -- 第二页 分页操作是一个MySQL“ 方言 ” DCL：管理用户&amp;授权 管理用户 添加用户 1CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 删除用户 1DROP USER '用户名'@'主机名'; 修改用户密码 12UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); 忘记root密码 管理员运行cmd —&gt; net stop mysql 使用无验证方式启动mysql：mysqld —skip-grant-tables; 修改root密码 在任务管理器中关闭mysqld.exe进程 查询用户 1234-- 切换到mysql数据库USE mysql;-- 查询user表SELECT * FROM USER; 注意：% 表示可以在任意主机使用用户登录 权限管理 查询权限 1SHOW GRANTS FOR '用户名'@'主机名'; 授予权限 123GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';-- 授予所有权限，在任意数据库任意表上GRANT ALL ON *.* TO '用户名'@'主机名'; 撤销权限 12-- 撤销权限REVOKE 权限列表 ON 数据库名.表名 from '用户名'@'主机名'; 约束 概念：对标重的数据进行限定，保证数据的正确性、有效性和完整性。 分类: 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束 not null： 创建表时添加约束： 1234CREATE TABLE stu( id INT, name VARCHAR(32) NOT NULL -- name 为非空约束); 创建表后添加约束： 1ALTER TABLE stu MODIFY name VARCHAR(32) NOT NULL; 删除非空约束 1ALTER TABLE stu MODIFY name VARCHAR(32); 唯一约束：unique 12345678CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE);ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;-- 若已有重复数据，则无法添加唯一约束-- mysql中 唯一约束限定的列的值可以有多个null 删除 12ALTER TABLE stu DROP INDEX phone_number;-- 注意，与非空约束方法不同 主键约束：primary key 基本概念： 含义：非空且唯一 一张表只有一个字段为主键 主键就是表中记录的唯一标识 123456CREATE TABLE stu( id INT PRIMARY KEY, name VARCHAR(20) );ALTER TABLE stu MODIFY id VARCHAR(20) PRIMARY KEY;-- 有重复或空则无法添加主键约束 删除 1ALTER TABLE stu DROP PRIMARY KEY; 自动增长： 概念：如果某一列是数值类型，使用 auto_increment 可以完成值的自动增长 创建表时，添加主键乐数，并完成主键自增长 1234567CREATE TABLE stu( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) );-- 之后不用输入id也可实现id的自增长，但也可手动输入INSERT INTO stu VALUES(NULL, 'ccc'); 删除：与非空约束方法相同，非空约束的删除 外键约束：foreign key，让表与表产生关系，从而保证数据的正确性 在创建表时可以添加外键 语法： 12345CREATE TABLE 表名( ...... 外键列,-- 注意这个逗号 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列的名称)); 1234567CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT, -- 外键对应主表的主键 CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id)) 删除外键 1ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk; 创建表后创建外键 1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列的名称); 级联操作： 设置级联更新 1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列的名称) ON UPDATE CASCADE; 设置级联删除 12-- 二者可以同时存在ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列的名称) ON DELETE CASCADE; 数据库的设计多表之间的关系 一对一 一个人只有一张身份证，一个身份证只能对应一个人 一对多（多对一） 一个部门有多个员工，一个员工只属于一个部门 多对多 一个学生可以选择很多门课程，一个课程也可以被很多学生选择 多表关系的实现 一对多（多对一）： 在多的一方建立外键，指向一的一方的主键 多对多： 需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。 一对一： 在任意一方添加唯一外键指向另一方的主键 范式 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类 第一范式(1NF)：每一列都是不可分割的原子数据项 第二范式(2NF)：在1NF基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 函数依赖：A—&gt;B，通过A的属性值，可以确定唯一B属性的值，则称B依赖于A。 如：学号—&gt;姓名 （学号，课程名称）—&gt; 分数 完全函数依赖：A—&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值 如：（学号，课程名称）—&gt; 分数 部分函数依赖：A—&gt;B，如果A 是一个属性组，则B属性值的确定只需要依赖于A属性值中某一些值即可 如：（学号，课程名称）—&gt; 姓名 传递函数依赖：A—&gt;B，B—C，称C传递依赖于A 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码 主属性：码属性组中的所有属性 非主属性：除去码属性组的属性 第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原 命令行 语法： 备份：mysqldump -u用户名 -p密码 数据库的名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件：source 文件路径 图形化工具 MySQL多表&amp;事务多表查询 查询语法: 123456select 列名列表from 表名列表where......-- 查询出的结果为多个表的笛卡儿积 分类 内连接查询 隐式内连接：使用where条件消除无用数据 12345678910SELECT * FROM emp, department WHERE emp.id = department.id;-- 或者使用别名SELECT t1.name, t1.gender, t2.nameFROM emp t1, department t2WHERE t1.id = t2.id; 显式内连接： select 字段列表 from 表名1 inner join 表名2 on 条件; select 字段列表 from 表名1 join 表名2 on 条件; 注意事项 从哪些表查找数据、条件是什么、查询哪些字段 外连接查询 左外连接 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件; 查询的是左表所有数据以及其交集部分 右外连接 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件; 查询的是右表所有数据以及其交集部分 子查询 概念：查询中嵌套查询，称嵌套查询为子查询 12-- 例子：查找工资最高的员工SELECT * FROM emp WHERE emp.`salary`=(SELECT MAX(salary) FROM emp); 不同情况 结果是单行单列 子查询可以作为条件，使用运算符判断，如上方例子 $&gt;,&lt;,&gt;=,&lt;=,=$， 结果是多行单列 子查询可以作为条件 12-- 例子：查询财务部和市场部的所有人员SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'); 结果是多行多列 子查询可以作为一张虚拟表来进行表的查询 12345-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息SELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2WHERE t1.id = t2.dept_id; 事务 基本介绍 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败 操作： 开启事务（start transaction） 回滚（rollback） 提交（commit） 12345678910111213141516171819202122-- 创建数据表CREATE TABLE account (id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(10),balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000);START TRANSACTION;-- 张三给李四转账500元-- 张三账户-500UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';-- 李四账户+500这里出错了......UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi';-- 发现执行没有问题，提交事务COMMIT;-- 发现出问题，回滚事务ROLLBACK; MySQL数据库总事务默认自动提交 一条DML(增删改)语句，会自动提交一次 事务提交的方式： 自动提交 手动提交： 需要先开启事务 修改默认提交方式 查看默认提交方式： SELECT @@autocommit; — 1代表自动提交，0代表手动提交 修改 ：SET @@autocommit = 0; 四大特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化地保存数据。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 事务隔离级别（了解） 多个事务操作同一批数据，可能出现问题。可通过设置不同隔离级别来解决这些问题。 问题 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读（虚读）：在同一个食物中，两次读取到的数据不一样 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改 隔离级别 read uncommitted 产生问题：脏读、不可重复读、幻读 read committed（Oracle默认） 产生问题：不可重复读、幻读 repeatable read（MySQL默认） 产生问题：幻读 serializable：串行化 可以解决所有问题 注：隔离级别从小到大安全性越来越高，效率越来越低 查询隔离级别：SELECT @@tx_isolation; 设置隔离级别：set global transaction isolation level 级别字符串;（需要重新打开生效）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript简要学习]]></title>
    <url>%2FJavascript%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介JavaScript： 是基于对象和事件驱动的语言，应用于客户端 基于对象： 提供了很多对象，可直接使用 事件驱动： 可以实现动态效果 客户端：指浏览器 特点： 交互性 信息的动态交互 安全性： js不能访问本地磁盘的文件 跨平台性： 通过浏览器实现 组成： （1）ECMAScript ECMA ：欧洲计算机协会 由ECMA组织指定的js语法和语句 （2）BOM browser object model 浏览器对象模型 （3）DOM document object model 文档对象模型 使用JS和HTML的结合方式 （1）使用script标签 1&lt;script type="text/javascript"&gt;&lt;/script&gt; （2）引入外部的js文件 1&lt;script type="text/javascript" srt="*.js"&gt;&lt;/script&gt; script标签放置：可以放在任何位置，但html是从上到下解析，所以最好放在&lt;/body&gt;后面，否则JavaScript可能获取不到input等标签里面的值。 原始类型和声明变量 js是弱类型语言 定义变量 使用关键字var 原始类型： string：字符串 1var str = "abc"; number：数字类型 1var num = 123; boolean：true or false null：获取对象的引用，null表示对象引用为空 1var date = new Date(); undefined：定义一个变量，没有赋值 1var aa; typeof()：可以查看变量的类型 语句 种类： if判断 switch语句：js所有类型都支持 循环 for while do-while 1234for(var i = 0; i &lt; 5; i++)&#123; &#125; 与java类似 运算符 与java中不同的： js中不区分整数和小数，123 / 1000 == 0.123 字符串相加和相减： “456” + 1 == “4561”（相加做字符串连接） “456” - 1 == “455”（相减进行真正的相减） “abc” - 1会提示NaN表示不是一个数字 boolean操作： true + 1 == 2 false + 1 == 1 即true是1，false是0 “ === ”和“ == ”： ==：值是否相等 ===：值和类型是否相等 补充：document.write()： 直接向页面写入内容，可以写入变量，固定值，html代码 数组 定义： （1）var[] arr = {1, 2, 3}; //数组可以存放不同的数据类型 （2）使用内置Array对象 1var arr1 = new Array(5); //建立有5个元素的数组 1var arr2 = new Array(3, 4, 5); //创建数组&#123;3, 4, 5&#125; 属性： （1）length：arr.length; 深入学习数组 函数 定义函数： （1）使用function关键字 12345function 方法名(参数列表)&#123; 方法体; （返回值）;&#125;//参数列表直接写参数名称，不用写var （2）匿名函数 123var 方法名 = function(参数列表)&#123; 方法体和返回值;&#125; （3）使用内置对象Function 12var add = new Function("参数列表", "方法体和返回值");//使用较少 全局变量和局部变量 全局变量：在script标签里定义一个变量，其在整个页面的js部分都可使用 方法内外，在另一个script标签使用 局部变量：在方法内部定义一个变量，只能在方法内部使用 重载 定义：函数名相同，函数参数列表不同(参数个数和参数类型)，根据参数不同去执行不同操作，但在js中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的。故JavaScript没有真正意义上的重载。 深入String对象 创建： 1var str = "abc"; 属性： length：字符串的长度 方法： （1）与HTML相关： bold：实现加粗 1document.write(str.bold()); fontcolor：修改字符串的颜色 1str2.fontcolor("red"); fontsize：修改字体大小 1str3.fontsize(5); link：将字符串显示为超链接 1str4.link("wnghilin.top"); sub、sup：将字符串显示为上下标 （2）与Java类似： concat：连接两个字符串 123456var str1 = "abc";var str2 = "gds";document.write(str1.concat(str2));输出结果：abcgds charAt：返回指定位置的字符 123var str3 = "abcdefg";str3.charAt(0);//返回astr3.charAt(20);//返回空字符串 indexOf：返回字符串位置，若不存在，返回-1 split：切分字符串，分为数组 12var str4 = "a-b-c-d";var arr1 = str4.split("-"); replace：替换字符串 1str6.replace("a", "6"); substr 和 substring：截取子字符串 123var str5 = "abcdefghuiop";str5.substr(5, 3); //fgh 从5开始向后开始截取3个字符str5.substring(3, 5); //de 从3位开始，第5位结束但不包含第5位 Array：数组对象 创建：链接 属性： length：数组的长度 方法： concat：数组拼接，用法类似字符串 join：根据指定字符分隔数组 123var arr = new Array("a", "b", "c");document.write(arr); //输出：a, b, cdocument.write(arr.join("-")); //输出：a-b-c push：向数组末尾添加一个或多个新的元素，并返回数组新的长度 &lt;注&gt;如果向末尾添加的是数组，会将整个数组看作一个元素将其加入到原有数组中 pop：删除并返回最后一个元素 reverse：反转数组 Date：日期对象 获取当前时间 123var date = new Date();date; //Fri Aug 02 2019 15:51:13 GMT+0800 (中国标准时间)date.toLocaleString();// 2019/8/2 下午3:53:45 获取当前年月日和星期 1234date.getFullYear(); //2019date.getMonth(); //7，因为返回结果是0-11月，需要再加一返回真实月数date.getDate(); //2date.getDay(); //5，返回0-6，星期日是0 获取当前时分秒 123date.getHours(); //16date.getMinutes(); //5date.getSeconds(); //36 获取毫秒数： 1date.getTime(); //1564733221660，1970年1月1日至今的毫秒数 Math：数学对象都是静态方法，只能通过类名+方法调用 方法： cell：上舍入 floor：下舍入 round：四舍五入 random：产生0.0到1.0之间的随机数 属性 PI：圆周率 E：自然对数的底数 RegExp：正则表达式对象 正则表达式：定义字符串的组成规则 单个字符：[ ] 如：[a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符： \d：单个数字字符[0-9] \w：单个单词字符[a-zA-Z0-9_] 量词符号： *：表示出现0次或多次 ?：表示出现0次或1次 +：表示出现1次或多次 {m,n}：表示 $m&lt;=数量&lt;=n$（逗号之后不能打空格） m如果缺省，{ ,n}：最多n次 n如果缺省，{m, }：最少m次 开始结束符号： ^：开始 $：结束 对象： 创建： var reg = new RegExp(“正则表达式”); var reg = /正则表达式/; 方法： test(参数)：验证指定的字符串是否符合正则定义的规范 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;RegExp对象&lt;/title&gt; &lt;script&gt; var reg1 = new RegExp("\\w&#123;6,12&#125;"); //此处两个\\，防止\w被转义为其他字符 var reg2 = /^\w&#123;6,12&#125;$/; alert(reg1); alert(reg2); var name = "zhangsan"; var flag = reg1.test(name); alert(flag); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; Global对象 特点：全局对象，不需要对象名就可以直接使用 eval：如果字符串是js代码，使用该方法直接执行 12var str = "alert(1234)";eval(str); //执行alert(1234) encodeURI 和 decodeURI：对字符进行编码和解码 将中文先编码再解码可以有效防止乱码 encodeURIComponent 和 decodeURIComponent： 与上面只有编码字符多少的差别 isNaN：判断当前字符串是否是数字，若是，返回false NaN参与的” == “比较，全部为false，包括NaN==NaN parseInt：解析字符串并返回一个整数 逐一判断每一个字符是否是数字，直到不是数字位置，将前面数字转为number 若第一个字符就是字母，则转为NaN 重载有没有重载？链接 重载可模拟实现 使用arguments对象实现，这个方法的缺点是麻烦。 1234567function overload()&#123; if(arguments.length === 1) console.log('一个参数'); else if(arguments.length === 2) console.log('两个参数');&#125;//参数通过arguments[0]...来使用 BOM对象 BOM：浏览器对象模型 有哪些对象： navigator：可以获取客户机的信息（浏览器的信息） navigator.appName; //显示浏览器的名称 screen：可返回屏幕信息 screen.width; //返回屏幕的宽 screen.height; //返回屏幕的高 location：请求url地址 href属性 获取请求的url地址，即浏览器地址栏的地址 设置url地址 可以设置页面按钮的事件，将其跳转到另外一个页面 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="跳转" onclick="href1()"&gt;&lt;/input&gt;&lt;/body&gt;&lt;script&gt; function href1() &#123; location.href="http://www.baidu.com"; &#125;&lt;/script&gt;&lt;/html&gt; history：请求url的历史记录 可以通过其实现浏览器前进后退功能 history.back(); //到上一个页面 history.forward(); //到下一个页面 history.go(1); //到下一个页面 history.go(-1); //到下一个页面 window window对象 窗口对象 顶层对象（所用的bom对象都是在window对象的里面操作的） 方法： window.alert()：弹出一个消息提示框 简写alert(); confirm()：确认提示框，参数为提示内容 返回值：若点击确认，则返回true，否则返回false prompt(text, defaultText)：输入对话框 text为提示输入，defaultText为默认输入内容 open(URL,name,features,replace)：打开一个新窗口，并返回窗口对象 URL： 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name： 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features： 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace： 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值： **true - URL**： 替换浏览历史中的当前条目。 ​ false - URL： 在浏览历史中创建新的条目。 close()：关闭窗口，浏览器兼容性较差 做定时器： setInterval(code, millisec)：每millisec毫秒执行一次code代码。 setTimeout(code, millisec)：在millisec毫秒后执行一次code代码，且只会执行一次 clearInterval(setInterval的返回值)：清除setInterval设置的定时器 clearTimeout(setTimeout的返回值)：清除setTimeout设置的定时器 DOM对象 DOM：文档对象模型 功能：控制html文档的内容 代码：获取页面标签（元素）对象 Element document.getElementById(“id值”); 通过元素的id来获得元素对象 操作Element对象： 修改属性值： 修改标签体内容： 属性：innerHTML 事件 功能：某些组件被执行了某些操作后，触发某些代码的执行 绑定事件 直接在html标签上，指定事件的属性，属性值就是js代码 事件：onclick：点击 1&lt;img id="light" src="img/off.gif" onclick="function();"&gt; 通过js获取元素对象，指定事件属性，设置一个函数 12345&lt;script&gt; var light = document.getElementById("light"); function fun2()&#123;&#125; light.onclick = fun2();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript简要学习]]></title>
    <url>%2FJavaWeb_Javascript%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介JavaScript： 是基于对象和事件驱动的语言，应用于客户端 基于对象： 提供了很多对象，可直接使用 事件驱动： 可以实现动态效果 客户端：指浏览器 特点： 交互性 信息的动态交互 安全性： js不能访问本地磁盘的文件 跨平台性： 通过浏览器实现 组成： （1）ECMAScript ECMA ：欧洲计算机协会 由ECMA组织指定的js语法和语句 （2）BOM browser object model 浏览器对象模型 （3）DOM document object model 文档对象模型 使用JS和HTML的结合方式 （1）使用script标签 1&lt;script type="text/javascript"&gt;&lt;/script&gt; （2）引入外部的js文件 1&lt;script type="text/javascript" srt="*.js"&gt;&lt;/script&gt; script标签放置：可以放在任何位置，但html是从上到下解析，所以最好放在&lt;/body&gt;后面，否则JavaScript可能获取不到input等标签里面的值。 原始类型和声明变量 js是弱类型语言 定义变量 使用关键字var 原始类型： string：字符串 1var str = "abc"; number：数字类型 1var num = 123; boolean：true or false null：获取对象的引用，null表示对象引用为空 1var date = new Date(); undefined：定义一个变量，没有赋值 1var aa; typeof()：可以查看变量的类型 语句 种类： if判断 switch语句：js所有类型都支持 循环 for while do-while 1234for(var i = 0; i &lt; 5; i++)&#123; &#125; 与java类似 运算符 与java中不同的： js中不区分整数和小数，123 / 1000 == 0.123 字符串相加和相减： “456” + 1 == “4561”（相加做字符串连接） “456” - 1 == “455”（相减进行真正的相减） “abc” - 1会提示NaN表示不是一个数字 boolean操作： true + 1 == 2 false + 1 == 1 即true是1，false是0 “ === ”和“ == ”： ==：值是否相等 ===：值和类型是否相等 补充：document.write()： 直接向页面写入内容，可以写入变量，固定值，html代码 数组 定义： （1）var[] arr = {1, 2, 3}; //数组可以存放不同的数据类型 （2）使用内置Array对象 1var arr1 = new Array(5); //建立有5个元素的数组 1var arr2 = new Array(3, 4, 5); //创建数组&#123;3, 4, 5&#125; 属性： （1）length：arr.length; 深入学习数组 函数 定义函数： （1）使用function关键字 12345function 方法名(参数列表)&#123; 方法体; （返回值）;&#125;//参数列表直接写参数名称，不用写var （2）匿名函数 123var 方法名 = function(参数列表)&#123; 方法体和返回值;&#125; （3）使用内置对象Function 12var add = new Function("参数列表", "方法体和返回值");//使用较少 全局变量和局部变量 全局变量：在script标签里定义一个变量，其在整个页面的js部分都可使用 方法内外，在另一个script标签使用 局部变量：在方法内部定义一个变量，只能在方法内部使用 重载 定义：函数名相同，函数参数列表不同(参数个数和参数类型)，根据参数不同去执行不同操作，但在js中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的。故JavaScript没有真正意义上的重载。 深入String对象 创建： 1var str = "abc"; 属性： length：字符串的长度 方法： （1）与HTML相关： bold：实现加粗 1document.write(str.bold()); fontcolor：修改字符串的颜色 1str2.fontcolor("red"); fontsize：修改字体大小 1str3.fontsize(5); link：将字符串显示为超链接 1str4.link("wnghilin.top"); sub、sup：将字符串显示为上下标 （2）与Java类似： concat：连接两个字符串 123456var str1 = "abc";var str2 = "gds";document.write(str1.concat(str2));输出结果：abcgds charAt：返回指定位置的字符 123var str3 = "abcdefg";str3.charAt(0);//返回astr3.charAt(20);//返回空字符串 indexOf：返回字符串位置，若不存在，返回-1 split：切分字符串，分为数组 12var str4 = "a-b-c-d";var arr1 = str4.split("-"); replace：替换字符串 1str6.replace("a", "6"); substr 和 substring：截取子字符串 123var str5 = "abcdefghuiop";str5.substr(5, 3); //fgh 从5开始向后开始截取3个字符str5.substring(3, 5); //de 从3位开始，第5位结束但不包含第5位 Array对象 创建：链接 属性： length：数组的长度 方法： concat：数组拼接，用法类似字符串 join：根据指定字符分隔数组 123var arr = new Array("a", "b", "c");document.write(arr); //输出：a, b, cdocument.write(arr.join("-")); //输出：a-b-c push：向数组末尾添加一个或多个新的元素，并返回数组新的长度 &lt;注&gt;如果向末尾添加的是数组，会将整个数组看作一个元素将其加入到原有数组中 pop：删除并返回最后一个元素 reverse：反转数组 Date对象 获取当前时间 123var date = new Date();date; //Fri Aug 02 2019 15:51:13 GMT+0800 (中国标准时间)date.toLocaleString();// 2019/8/2 下午3:53:45 获取当前年月日和星期 1234date.getFullYear(); //2019date.getMonth(); //7，因为返回结果是0-11月，需要再加一返回真实月数date.getDate(); //2date.getDay(); //5，返回0-6，星期日是0 获取当前时分秒 123date.getHours(); //16date.getMinutes(); //5date.getSeconds(); //36 获取毫秒数： 1date.getTime(); //1564733221660，1970年1月1日至今的毫秒数 Math对象都是静态方法，只能通过类名+方法调用 方法： cell：上舍入 floor：下舍入 round：四舍五入 random：产生0.0到1.0之间的随机数 属性 PI：圆周率 E：自然对数的底数 全局函数 不属于任何对象，致谢写名称使用 eval：如果字符串是js代码，使用该方法直接执行 12var str = "alert(1234)";eval(str); //执行alert(1234) encodeURI 和 decodeURI：对字符进行编码和解码 将中文先编码再解码可以有效防止乱码 encodeURIComponent 和 decodeURIComponent： 与上面只有编码字符多少的差别 isNaN：判断当前字符串是否是数字，若是，返回false parseInt：解析字符串并返回一个整数 重载有没有重载？链接 重载可模拟实现 使用arguments对象实现，这个方法的缺点是麻烦。 1234567function overload()&#123; if(arguments.length === 1) console.log('一个参数'); else if(arguments.length === 2) console.log('两个参数');&#125;//参数通过arguments[0]...来使用 BOM对象 BOM：浏览器对象模型 有哪些对象： navigator：可以货期客户机的信息（浏览器的信息） navigator.appName; //显示浏览器的名称 screen：可返回屏幕信息 screen.width; //返回屏幕的宽 screen.height; //返回屏幕的高 location：请求url地址 reload() 重新加载当前文档，刷新 href属性 获取请求的url地址，即浏览器地址栏的地址 设置url地址 可以设置页面按钮的事件，将其跳转到另外一个页面 123456789101112131415 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="跳转" onclick="href1()"&gt;&lt;/input&gt; &lt;/body&gt; &lt;script&gt; function href1() &#123; location.href="http://www.baidu.com"; &#125; &lt;/script&gt;&lt;/html&gt; history：请求url的历史记录 可以通过其实现浏览器前进后退功能 history.back(); //到上一个页面 history.forward(); //到下一个页面 history.go(1); //到下一个页面 history.go(-1); //到下一个页面 window window对象 窗口对象 顶层对象（所用的bom对象都是在window对象的里面操作的） 方法： window.alert()：弹出一个消息提示框 简写alert(); confirm()：确认提示框，参数为提示内容 返回值：若点击确认，则返回true，否则返回false prompt(text, defaultText)：输入对话框 text为提示输入，defaultText为默认输入内容 open(URL,name,features,replace)：打开一个新窗口，并返回窗口对象 URL： 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name： 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features： 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace： 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值： **true - URL**： 替换浏览历史中的当前条目。 ​ false - URL： 在浏览历史中创建新的条目。 close()：关闭窗口，浏览器兼容性较差 关闭调用该方法的窗口 定时器有关方法： setInterval(code, millisec)：每millisec毫秒执行一次code（js代码或方法对象）代码 setInterval(“fun();”, 3000); setInterval(fun, 3000); setTimeout(code, millisec)：在millisec毫秒后执行一次code代码，且只会执行一次 clearInterval(setInterval的返回值)：清除setInterval设置的定时器 clearTimeout(setTimeout的返回值)：清除setTimeout设置的定时器 DOM对象简介 DOM：文档对象模型 文档：超文本标记文档 可以用DOM提供的对象，对标记型文档进行操作，但需要把标记型文档里的所有内容封装成对象 用DOM解析html：根据html层级结构，在内存中分配一个树形结构，需要把html中的每部分封装成对象 注意每个标签节点后还有文本节点 Document对象：整个html文档 Element对象：标签对象 Attribute对象：属性对象 Text对象：文本对象 Comment对象：注释对象 Node节点对象：是这些对象的父对象 核心DOM模型 Document对象：整个html文档 创建（获取） window.document(window可省略) 方法 获取Element对象 getElementById() 查找具有指定的唯一 ID 的元素 getElementsByTagName() 根据元素名称获取元素对象（多个），返回值是数组 getElementsByClassName() 根据Class属性值获取元素对象们，返回值是数组 getElementsByName() 根据name属性值获取元素对象们 创建其他DOM对象 createAttribute(name) createComment() createElement() createTextNode() 属性 Element对象：标签对象 通过Document对象获取 方法 removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象 特点：所有DOM对象都可以被认为是节点 方法： CRUD DOM树： appendChild()：项节点的子节点列表的结尾添加新的子节点 removeChild()：删除（并返回）当前节点指定的子节点 replaceChild()：用新节点替换一个子节点 属性： parentNode：返回当前节点的父节点 HTML DOM 标签体的设置和获取：innnerHTML 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTMLDOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; div &lt;/div&gt; &lt;script&gt; var div = document.getElementById("div1"); //div中替换一个文本输入框 div.innerHTML = "&lt;input type='text'&gt;" //div中增加一个文本输入框 div.innerHTML += "&lt;input type='text'&gt;" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 1234567&lt;!-- 方式1 --&gt; var div1 = document.getElementById("div1"); div1.onclick = function () &#123; div1.style.border = "1px solid red"; div1.style.width = "200px"; div1.style.height = "200px"; &#125; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值 1234567891011121314151617... &lt;style&gt; .d2&#123; border: 1px solid #c4ff9e; width: 200px; height: 200px; &#125; &lt;/style&gt;... &lt;script&gt; &lt;!-- 方式2 --&gt; var div2 = document.getElementById("div2"); div2.onclick = function () &#123; div2.className = "d2" &#125; &lt;/script&gt;... 事件 概念：某些组件被执行了某些操作后，触发某些代码的执行 事件：某些操作，如：单击、双击、键盘按下、鼠标移动 事件源：组件，如：按钮、文本输入框 监听器：代码 注册监听：将事件、事件源、监听器结合在一起。当事件源上发生了某个事件，则出发执行某个监听器代码 常见的事件： 点击事件 onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 onfocus：元素获得焦点 加载事件 onload：一张页面或一幅图像完成加载 鼠标事件 onmousedown：鼠标按钮被按下 onmousemove：鼠标被移动 onmouseover：鼠标移到某元素之上 onmouseup：鼠标按键被松开 123document.getElementById("text").onmousedown=function(event)&#123; event.button;//button值为0，左键被点击；1为中建，2为右键&#125; 键盘事件 onkeydown：某个键盘按键被按下 onkeyup：某个键盘按键被松开 onkeypress：某个键盘按键按下再松开 选择和改变 onchange：域的内容被改变 onselect：文本被选中 表单事件： onsubmit：确认按钮被点击 用于阻止表单提交，如果该事件方法返回值为false，则表单不会提交 onreset：重置按钮被点击]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS简要学习]]></title>
    <url>%2Fcss%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSS简介 css：层叠样式表 样式表：有很多属性和属性值 css可以使得页面显示效果更好，可以提高后期样式代码的可维护性 CSS使用CSS和HTML的四种结合方式 （1）style属性： 1&lt;div style = "background-color:red;color:green"&gt;内容&lt;/div&gt; style属性示例 （2） style标签： 123456&lt;!--- 此处可以设置&lt;div&gt;标签的样式 ---&gt;&lt;style type="text/css"&gt; div&#123; css代码; &#125;&lt;/style&gt; style标签示例 （3）在style标签 使用语句： 创建css文件（.css） 在style标签中使用@import url(css文件路径)； （4）使用头标签引入外部css文件 创建css文件 1&lt;link rel="stylesheet" type="text/css" href="css路径"&gt; 注：第三种方式在某些浏览器下不起作用，一般用第四种 CSS优先级优先级：即最终以哪一个样式为准 从上到下，从内到外，优先级从低到高。（一般情况） 即html中，以在下方的和内部的样式为准 格式：选择器名称{属性名: 属性值; ······} CSS基本选择器种类 （1）标签选择器：用标签的名称作为选择器 （2）class选择器： 每个html标签都有个属性 class 123&lt;!--- 此处可以用class1作为选择器 ---&gt;&lt;div class="class1"&gt;&lt;/div&gt;&lt;p class="class1"&gt;&lt;/p&gt; 1234567div.class1&#123; css代码;&#125;/*此处修改所有class属性为class1的样式*/.class1&#123; css代码；&#125; （3）id选择器： 1&lt;div id="id1"&gt;&lt;/div&gt; 1234567div#id1&#123; css代码;&#125;/*此处修改所有id属性为id1的样式*/#id1&#123; css代码;&#125; 优先级 id选择器 &gt; class选择器 &gt; 标签选择器 CSS扩展选择器 （1）关联选择器 123&lt;div&gt;&lt;p&gt; 内容 &lt;/p&gt;&lt;/div&gt; 设置嵌套标签里的样式： 1234/*div里的p标签*/div p&#123; css代码;&#125; （2）组合选择器 12345&lt;div&gt; &lt;p&gt; 内容 &lt;/p&gt;&lt;/div&gt; 将div和p设置为相同样式 123div,p&#123; css代码;&#125; （3）伪元素选择器 css提供的定义好的样式，可以直接选用 比如超链接： 状态：原始 悬停 点击 点击后 原始： :link 悬停： :hover 点击： :active 点击后： :visited 123a:hover&#123; css代码;&#125; CSS盒子模型在布局前需要把数据装到一块一块的区域内，这个区域叫做盒子。 Margin(外边距) - 清除边框外的区域，外边距是透明的。 与边框类似 Border(边框) - 围绕在内边距和内容外的边框。 上：border-top 下：border-bottom 左：border-left 右：border-right 12345678/*统一设置*/div&#123; border: 2px solid blue;&#125;/*分别设置*/div#id1&#123; border-left: 2px dashed yellow;&#125; Padding(内边距) - 清除内容周围的区域，内边距是透明的。 与边框类似 Content(内容) - 盒子的内容，显示文本和图像。 布局的漂浮 float: 用于设置布局悬浮 none: 默认值，对象不漂浮。 left: 文本流向对象的右边。（其后面的部分漂向它的右边，空出的位置由剩下的补齐） right: 文本流向对象的左边。 缺点：在某些浏览器上无法使用 布局的定位 position: 用于设置布局定位 absolute: 将对象从文档流中拖出，其原来的位置由后面的补上 可用 top、left等对它进行绝对定位。 relative: 不从文档流中拖出，其余盒子位置不变 学习资料：(28天完整版)JavaWeb视频教程 资料、图片来源：CSS 盒子模型]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb基础概念]]></title>
    <url>%2FJavaWeb%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[反射 框架：软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。也被称为半成品软件。可以在框架的基础上进行软件开发，可以简化编码。 概念 反射：将类的各个组成部分封装为其他对象，这就是反射机制。（在Class 类对象阶段，将.class文件的各个部分封装成不同的类对象，如将成员变量封装成Field类对象并用数组存储起来。其总体是由Class类对象储存的） 好处：* 1.可以在程序运行过程中操作这些对象。 * 2.可以解耦 获取字节码class对象的三种方式 获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()在Object类中定义 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 class类对象的获取功能 Class对象功能： 获取功能： 获取成员变量： getFields() ：获取所有public修饰的成员变量，private或protected修饰的无法读取 getField(String name) 获取指定名称的 public修饰的成员变量 getDeclaredFields() 获取所有的成员变量，不考虑修饰符 getDeclaredField(String name) 1234567891011//用法示例 public class reflectDemo &#123; public static void main(String[] args) &#123; Class&lt;Person&gt; personClass = Person.class; Field[] fields = personClass.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125; Field a = personClass.getField("a"); &#125; &#125; 成员变量的操作（Field类的方法） 1. 设置值 - void set(Object obj, Object value) 12Person p = new Person();a.set(p, "a"); //设置p对象的a属性的值 2. 获取值 - get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射，设置之后即可访问private和protected修饰的变量 2. 获取构造方法： * getConstructors() * getConstructor(类&lt;?&gt;... parameterTypes) * getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * getDeclaredConstructors() 123456public class reflect &#123; public static void main(String[] args) throws Exception &#123; Constructor cons = cls2.getConstructor(String.class, int.class); System.out.println(cons); &#125;&#125; * Constructor对象的操作： * 创建对象： * newInstance方法 * 用空参数构造方法创建对象，可以用Class对象的newInstance方法 * 暴力反射 3. 获取成员方法： * Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) * 操作： * 执行方法：invoke方法，参数为一个对象 * 获取方法名称：getname 4. 获取全类名 * String getName() 实例 案例： 需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现： 配置文件 反射 步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 12345678910111213141516171819202122232425262728public class reflectTest &#123; public static void main(String[] args) throws Exception&#123; //加载配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录的配置文件 ClassLoader classLoader = reflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream("pro.properties"); pro.load(is); //2.获取配置文件中的数据 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125; 注解 概念：说明程序的。给计算机看的 注释：用文字描述程序的。给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类：①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】②代码分析：通过代码里标识的注解对代码进行分析【使用反射】③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 内置注解 @Override：检测被该注解标注的方法是否是继承自父类（接口）的。 @Deprecated：该注解标注的内容，已过时 @SuppressWarnings：压制警告 @SuppressWarnings(“all”)：压制所有警告 自定义注解 格式： 1234元注解 public @interface 注解名&#123; 属性列表 &#125; 本质： 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 其本质上就是一个接口，该接口默认继承Annotation接口 属性：接口中可以定义的成员方法 要求： 属性的返回值类型： 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，使用时需要给属性赋值 1234567891011121314//定义public @interface MyAnno &#123; int age(); String name() default "张三" Person person();//此处为枚举类型 MyAnno2 anno2();//此处为另一个注解 String[] strs();&#125;//使用，有默认值的不需要赋值@MyAnno(show1 = 1, person = Person.P1, anno2 = @MyAnno, strs = &#123;"aaa","bbb"&#125;)public class AnnoDemo1 &#123;&#125; 特殊情况：如果只有一个属性需要赋值且属性名是value时，可以省略value，即MyAnno(1)。 元注解：解释注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述直接是否被抽取到API文档中 @Inherited：描述注解是否被子类继承 123456789import java.lang.annotation.*;@Target(value=&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface MyAnno3 &#123;&#125; 解析注解 解析注解：获取注解中定义的属性值，可以不再使用配置文件 1.获取注解定义的位置的对象（Class，Method，Field） 2.获取指定的注解 getAnnotation(Class) ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344//注解定义import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 描述需要执行的类名和方法名 */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String classname(); String methodname();&#125;//实现import java.lang.reflect.Method;@Pro(classname = "top.wnghillin.annotation.Student", methodname = "study")public class reflectTest &#123; public static void main(String[] args) throws Exception&#123; //1.解析注解 //1.1获取该类的字节码文件对象 Class&lt;reflectTest&gt; reflectTestClass = reflectTest.class; //2获取注解对象 Pro an = reflectTestClass.getAnnotation(Pro.class); //3.调用注解对象中定义的抽象方法，获取返回值 String classname = an.classname(); String methodname= an.methodname(); //4.加载该类进内存 Class cls = Class.forName(classname); //5.创建对象 Object obj = cls.newInstance(); //6.获取方法对象 Method method = cls.getMethod(methodname); //7.执行方法 method.invoke(obj); &#125;&#125; 附：isAnnotationPresent(MyAnno.class)：判断该方法（对象、属性）是否被MyAnno注解 资料：黑马JavaWeb入门到精通(idea版))]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
        <tag>反射</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Junit进行单元测试]]></title>
    <url>%2FJunit%2F</url>
    <content type="text"><![CDATA[预备知识 黑箱测试：不需要输入代码，只看输入输出 白箱测试：需要输入代码进行测试 （其中，使用Junit进行测试是白箱测试 ） Junit使用 步骤： 定义一个测试类 ​ 建议使用被测试的类名+Test命名 ​ 可以建立一个新的test包储存测试类 定义测试方法，该测试方法可以独立运行： ​ 加上@Test，如下方代码 1234@Testpublic void testAdd()&#123; &#125; 导入Junit依赖环境 使用断言来判断结果: 判定结果：红色：失败 绿色：成功 1234567@Testpublic void testAdd()&#123; Calculator c = new Calculator(); int result = c.add(1, 2); Assert.assertEquals(期望结果，运算结果)(2, result); //Assert.assertEquals(期望结果，运算结果)&#125; 失败结果： 123java.lang.AssertionError: Expected :2Actual :3 @Before @After方法1234567891011121314151617/** * 初始化方法 * 所有测试方法执行之前都将执行这个方法 */ @Before public void init()&#123; System.out.println("init..."); &#125; /** * 释放资源方法 * 所有测试方法执行之后都会自动执行这个方法 */ @After public void close()&#123; System.out.println("close..."); &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 树]]></title>
    <url>%2F%E7%AC%AC4%E7%AB%A0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[预备知识 树（tree）是一些节点的集合，其可以为空集；若它不为空集，则一棵树由根（root）节点 r 以及0个或多个非空的子树T1、T2……组成，其中每一刻的根都被来自根 r 的一条有向的边（edge）所连接。 树的实现实现树的一种方法可以是在每一个节点除数据外还要有一些指针，使得该节点的每一个儿子都有一个指针指向它。但由于节点的儿子个数未知且可能变化很大，因此只能通过将每个节点的所有儿子都放在树节点的链表中。 123456typedef struct TreeNode *PtrToNodestruct TreeNode&#123; ElementType Element; PtrToNode FirstChild; PtrToNode NextSibling;&#125;; 如图所示： 树的遍历及应用 先序遍历（preorder traversal）：在先序遍历中，对节点的处理工作是在它的诸儿子节点被处理之前（pre）进行的。其每个节点总的工作量为常数。其时间复杂度为O(N)。例子如下： 12345678910111213141516//计算机中的文件系统可以用一个树来表示static void ListDir(DirectoryOrFile D, int Depth)&#123; if(D is a legitimate entry) &#123; PrintName(D, Depth); if(D is a Directory) for each child, C, of D ListDir(C, Depth + 1); &#125;&#125;void ListDirectory(DirectoryOrFile D)&#123; ListDir(D, 0);&#125; 列出分级文件系统中目录的例程 后序遍历（postorder traversal）：在后序遍历中，在一个节点处的工作实在它的诸儿子节点被计算后（post）进行的。例子如下： 1234567891011121314static void SizeDirectory(DirectoryOrFile D)&#123; int TotalSize; TotalSize = 0; if(D is a legitimate entry) &#123; TotalSize = FileSize(D); if(D is a directory) for each child, C, of D TotalSize += SizeDirectory(C); &#125; return TotalSize;&#125; 计算一个目录大小的例程 二叉树 二叉树（binary tree）是一棵树，其中每个节点都不能有多于两个的儿子。 二叉树的深度可以远小于N，而其平均深度可以达到：$O(\sqrt(N))$，而二叉树的特殊情况，二叉查找树的深度平均值可以达到O(logN)。 实现 二叉树的一个节点就是由Key(关键字)信息加上两个指向其他节点的指针(Left和Right)组成的结构。 123456789typedef struct TreeNode *PtrToNode;typedef struct PtrToNode Tree;struct TreeNode&#123; ElementType Element; Tree Left; Tree Right;&#125;; 表达式树表达式树的树叶是操作数，如常数或变量，而其他节点为操作符（需要所有操作都是二元的）。 这种先读左儿子，再读节点，再读右儿子得到中缀表达式的方法，称为中序遍历，而采用后序遍历将会得到后缀表达式。 构造一颗表达式树设输入为 a b + c d e + * *前两个符号式操作数，因此我们创建两颗单节点树并把指向它们的指针压入栈中： 接着，“ + ”被读入，指向这两棵树的指针被弹出，形成一棵新的树： 随后，c、d、e被读入，同理，压入栈中： 接下来读入“ + ”号，d、e弹出并合并。继续读读到“ * ”号，再将两棵树合并，结果为： 随后同理，即可得到最终结果。 查找树ADT——二叉查找树性质 对于树中的每个节点X，它的左子树中的所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。这意味着，该树所有的元素都可以用某种统一的方式排序。 MakeEmpty123456789101112131415161718typedef SearchTree *Node;struct Node&#123; int element; SearchTree left; SearchTree right;&#125;;SearchTree MakeEmpty(SearchTree tree)&#123; if (tree != NULL) &#123; MakeEmpty(tree-&gt;left); MakeEmpty(tree-&gt;right); free(tree); &#125; return NULL; Find123456789101112typedef struct TreeNode *Position;Position Find(ElementType X, SearchTree T)&#123; if(T == NULL) return NULL; if(X &lt; T-&gt;Element) return Find(X, T-&gt;Left); else if (X &gt; T-&gt;Element) return Find(X, T-&gt;Right); else return T;&#125; FindMin 和 FindMax123456789101112131415161718//以下分别采用了递归和非递归的方法来实现Position FindMin(SearchTree T)&#123; if(T == NULL) return NULL; else if(T-&gt;Left == NULL) return T; else return FindMin(T-&gt;Left);&#125;Position FindMax(SearchTree T)&#123; if(T != NULL) while(T -&gt; NULL) T = T-&gt;Right; return T;&#125; Insert123456789101112131415161718192021SearchTree Insert(ElementType X, SearchTree T)&#123; if(T == NULL) &#123; //建立并返回一个单节点树 T = (SearchTree)malloc(sizeof(struct TreeNode)); if(T == NULL) FatalError("Out of space!!!"); else &#123; T-&gt;Element = X; T-&gt;Left = T-&gt;Right = NULL; &#125; &#125; else if(X &lt; T-&gt;Element) T-&gt;Left = Insert(X, T-&gt;Left); else if(X &gt; T-&gt;Element) T-&gt;Right = Insert(X, T-&gt;Right); //如果X已经在树里面，则不进行操作 return T;&#125; Delete删除是最困难的操作。如果节点是一片树叶，那么它可以被立即删除。如果节点有一个儿子，则该节点可以在其父节点跳帧指针绕过该节点后被删除。如图： 删除具有两个儿子的节点，一般的策略是用其右子树的最小的数据代替该节点的数据并递归地删除那个节点。 12345678910111213141516171819202122232425262728SearchTree Delete(ElementType X, SearchTree T)&#123; Position TmpCell; if(T == NULL) Error("Element Not Found"); else if(X &lt; T-&gt;Element) T-&gt;Left = Delete(X, T-&gt;Left); else if(x &gt; T-&gt;Element) T-&gt;Right = Delete(X, T-&gt;Right); else if(T-&gt;Left &amp;&amp; T-&gt;Right) &#123; TmpCell = FindMin(T-&gt;Right); T-&gt;Element = TmpCell-&gt;Element; T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right); &#125; else //1个或0个儿子 &#123; TmpCell = T; if(T-&gt;Left == NULL) T = T-&gt;Right; else if(T-&gt;Right == NULL) T = T-&gt;Left; free(TmpCell); &#125; return T;&#125; AVL树性质 AVL树是带有平衡条件的二叉查找树。这个平衡条件必须容易保持，且它须保证树的深度是O(logN). 一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1。） 旋转在插入一个节点后，可能会破坏AVL树的特性，如果发生这种情况，那么就要把性质恢复以后才认为这一步插入完成。事实上，这总可以通过旋转（rotation）做到。 不平衡可能出现的情况： 对$\alpha$的左儿子的左子树进行一次插入。 对$\alpha$的左儿子的右子树进行一次插入。 对$\alpha$的右儿子的左子树进行一次插入。 对$\alpha$的右儿子的右子树进行一次插入。 左-左（或右-右）的情况需要进行一次单旋转（single rotation）而完成调整，另外两种需要进行一次双旋转（double rotation）。 单旋转左子树的左子树变为节点的左子树，在将原来的左子树变为右子树，原来的右子树变为右子树的右子树。 单旋转修复情形1]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 表、栈和队列]]></title>
    <url>%2F%E7%AC%AC3%E7%AB%A0%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[表ADT基本概念​ 空表（empty list）：大小为0的表。 ​ 前驱元、后继元。 链表函数原型 123456789101112struct Node;typedef struct Node *PtrToNode;typedef PtrToNode List;typedef PtrToNode Position;List MakeEmpty(List L);int IsEmpty(List L);int IsLast(Position P, List L);Position Find(int X, List L);void Insert(int X, List L, Position P);void DeleteList(List L);Position Header(List L); 具体实现：略 常见的错误链表一般会出现指针变量包含了伪地址的问题。删除表时，需要一个中间量来储存上一个节点。同时，使用malloc之后记得将该节点初始化。 例子多项式ADT令F(X) = ∑i=0N AiXi。如果多项式的次数过大，使用普通方法的运行时间就难以接受了。于是可以采用多项式ADT来实现多项式的加减乘等操作。 多项式ADT的数组实现的类型声明 12345typedef struct&#123; int CoeffArray[MaxDegree + 1]; int HighPower;&#125; * Polynomial; 将多项式初始化为零的过程 12345678void ZeroPolynomial(Polynomial Poly)&#123; int i; for(i = 0; i &lt;= MaxDegree; i++) Poly-&gt;CoeffArray[i] = 0; Poly-&gt;HighPower = 0;&#125; 两个多项式相加的过程 12345678void AddPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolySum)&#123; int i; ZeroPolynomial(PolySum); PolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower); for(i = PolySum-&gt;HighPower; i &gt;= 0; i--) PolySum-&gt;CoeffArray[i] = Poly1-&gt;CoeffArray[i] + Poly2-&gt;CoeffArray[i];&#125; 两个多项式相乘的过程 12345678910111213void MultPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)&#123; int i, j; ZeroPolynomial(PolyProd); PolySum-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower; if(PolyProd-&gt;HighPower &gt; MaxDegree) Error("Exceeded array size"); else for(i = 0; i &lt;= Poly1-&gt;HighPower; i++) for(j = 0; j &lt;= Poly2-&gt;HighPower; j++) PolyProd-&gt;CoeffArray[i + j] += Poly1-&gt;CoeffArray[i] * Poly2-&gt;CoeffArray[j];&#125; 栈ADT栈模型栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，即顶（top）。对栈的基本操作有Push和Pop。 栈有时又叫LIFO(后进先出)表。 栈的实现链表实现栈ADT链表实现的类型声明 1234567891011struct Node;typedef struct Node *PtrToNode;typedef PtrToNode Stack;int IsEmpty(Stack S);Stack CreateStack(void);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S); 测试栈是否空栈的例程* 1234int IsEmpty(Stack S)&#123; return S-&gt;Next == NULL;&#125; 创建一个空栈的例程 1234567891011121314151617181920Stack CreateStack(void)&#123; Stack S; S = malloc(sizeof(struct Node)); if(S == NULL) FatalError("Out of space!!"); S-&gt;Next == NULL; MakeEmpty(S); return S;&#125;//MakeEmpty设置Next指针指向NULLvoid MakeEmpty(Stack S)&#123; if(S == NULL) Error("Must use CreateStack First"); else while(!IsEmpty(S)) Pop(S);&#125; Push进栈的例程 1234567891011121314void Push(int X, Stack S)&#123; PtrToNode TmpCell; TmpCell - malloc(sizeof(struct Node)); if(TmpCell == NULL) FatalError("Out of space!!"); else &#123; TmpCell-&gt;Element = X; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell; &#125;&#125; 返回栈顶元素的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Next-&gt;Element; Error("Empty Stack"); return 0;&#125; 从栈弹出元素的例程 123456789101112void Pop(Stack S)&#123; PtrToNode FirstCell; if(IsEmpty(S)) Error("Empty Stack!"); else &#123; FirstCell = S-&gt;Next; S-&gt;Next = S-&gt;Next-&gt;Next; free(FirstCell); &#125;&#125; ​ 所有操作均花费常数时间，但对于malloc和free的调用是非常昂贵的。有的缺点可以通过使用第二个栈避免，该第二个栈初始时为空栈。当一个单元栋第一个栈弹出时，它只是被放到了第二个栈中，此后当第一个栈需要新单元时，它首先去检查第二个栈 数组实现数组实现的栈可以避免指针的操作。其惟一潜在危害就是我们需要提前声明一个数组的大小。但通常来说声明一个足够大而不至于浪费太多空间的数组并不是太过困难，因此数组实现是一种比较流行的做法。 栈的声明 1234567891011121314#define EmptyTOS (-1)#define MinStackSize (5)struct StackRecord;typedef struct StackRecord *Stack;int IsEmpty(Stack S);int IsFull(Stack S);Stack CreateStack(int MaxElements);void DisposeStack(Stack S);void MakeEmpty(Stack S);void Push(int X, Stack S);int Top(Stack S);void Pop(Stack S);int TopAndPop(Stack S); 栈的创建 1234567891011121314151617Stack CreateStack(int MaxElements)&#123; Stack S; if(MaxElements &lt; MinStackSize) Error("Stack size is too small"); S = (Stack)malloc(sizeof(strct StackRecord)); if(S == NULL) FatalError("Out of Space!!!"); S-&gt;Array = (int *)malloc(sizeof(int) * MaxElements); if(S-&gt;Array == NULL) FatalError("Out of space!!!"); S-&gt;Capacity = MaxElements; MakeEmpty(S); return S;&#125; 栈的释放 12345678void DisposeStack(Stack S)&#123; if(S != NULL) &#123; free(S-&gt;Array); free(S); &#125;&#125; 检测是否空栈 1234int IsEmpty(Stack S)&#123; return S-&gt;TopOfStack == EmptyTOS;&#125; 创建一个空栈 1234void MakeEmpty(Stack S)&#123; S-&gt;TopOfStack = EmptyTOS;&#125; 进栈的例程 1234567void Push(int X, Stack S)&#123; if(IsFull(S)) Error("Full stack"); else S-&gt;Array[++S-&gt;TopOfStack] = X;&#125; 将栈顶返回的例程 1234567int Top(Stack S)&#123; if(!IsEmpty(S)) return S-&gt;Array[S-&gt;TopOfStack]; Error("Empty stack"); return 0;&#125; 从栈弹出元素的例程 1234567void Pop(Stack S)&#123; if(IsEmpty(S)) Error("Empty stack"); else S-&gt;TopOfStack--;&#125; 应用平衡符号做一个空栈。读入字符知道文件尾。如果字符时一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则当栈空时报错。否则，将栈元素弹出，如果弹出的符号不是对应的开放符号，则报错。在文件尾，如果栈非空则报错。 后缀表达式中缀表达式：4.99 + 5.99 + 6.99 * 1.06 后缀表达式：4.99 1.06 5.99 + 6.99 1.06 + （后缀（postfix）或逆波兰（reverse Polish）记法） 计算后缀表达式的方法是使用一个栈，当见到一个数字时就把它推入到栈中；遇到一个运算符时该运算符就作用于从该栈弹出的两个数（符号）上，将所得结果推入栈中。 如，计算 6 5 3 2 + 8 + 3 + ： TopOfStack-&gt; 3 2 5 6 下面读到一个‘+’，所以3和2被弹出，其结果5被压入栈中： TopOfStack-&gt; 5 5 6 接着，8进栈： TopOfStack-&gt; 8 5 5 6 然后，8和5弹出，相乘，再将40压入栈中： TopOfStack-&gt; 40 5 6 接着又遇到‘+’号，因此40和5被弹出，并且40 + 5 = 45进栈： TopOfStack-&gt; 45 6 随后操作同上，得到结果288。 中缀到后缀的转换设我们想将中缀表达式： a + b * c + (d * e + f) * g 转换成后缀表达式，其答案为 a b c * + d e * f + g * +首先，a被读入，于是它流向输出。然后，“+”被读入并被放入栈中。接着b读入并流向输出： Stack Output + a b 这时“ ”读入。操作符栈顶元素比较低，故没有输出，“ ”进栈。接着c被读入并输出： Stack Output * + a b c 后面是一个“ + ”号。其优先级比“ ”低，因此将“ ”从栈弹出并放入输出中；弹出剩下的“ + ”，因为其不比“ + ”优先级低，而是具有相同的优先级，然后将“ + ”压入栈中。 Stack Output + a b c * + 随后操作同上，需要注意的是“ （ ”的优先级最高，遇到“ ）”时要将所有符号弹出，直到遇到” （ “。 函数调用​ 尾递归（tail recursion）是使用递归极端不当的例子。尾递归可以通过将递归调用变成goto语句并在其前加上对每个函数的赋值语句而手动消除。很多编译器都能自动消除尾递归，但最好还是通过手动进行消除。 队列ADT队列模型​ 队列的基本操作是Enqueue和Dequeue。 队列的数组实现​ 对于每一个队列数据结构，我们保留一个数组Queue[ ]以及Front和Rear，还有记录实际存在于队列中的元素的个数Size。 ​ 为使一个元素X入队，我们让Size和Rear都增加1，然后置Queue[ Rear] = X。若使一个元素出队，我们置返回值为Queue[front]，Size减1，然后让Front增加1。 ​ 为了防止不出界，该操作需要使用循环数组（circular array）实现。 队列的类型声明 123456789101112struct QueueRecord;typedef struct QueueRecord *Queue;int IsEmpty(Queue Q);int IsFull(Queue Q);Queue CreateQueue(int MaxElements);void DisposeQueue(Queue Q);void MakeEmpty(Queue Q);void Enqueue(int X, Queue Q);int Front(Queue Q);void Dequeue(Queue Q);int FrotAndDequeue(Queue Q); 测试队列是否为空的例程 1234int IsEmpty(Queue Q)&#123; return Q-&gt;Size == 0;&#125; 构造空队列的例程 123456void MakeEmpty(Queue Q)&#123; Q-&gt;Size = 0; Q-&gt;Front = 1; Q-&gt;Rear = 0;&#125; 入队的例程 1234567891011121314151617static int Succ(int Value, Queue Q)&#123; if(++Value == Q-&gt;Capacity) Value = 0; return Value;&#125;void Enqueue(int X, Queue Q)&#123; if(IsFull(Q)) Error("Full queue"); else &#123; Q-&gt;Size++; Q-&gt;Rear = Succ(Q-&gt;Rear, Q); Q-&gt;Array[Q-&gt;Rear] = X; &#125;&#125; 出队的例程 12345678910111213void Dequeue(Queue Q)&#123; int returnNum; if(IsEmpty(Q)) Error("Empty Queue"); else &#123; returnNum = Q-&gt;Array[Q-&gt;Front]; Q-&gt;Front = Succ(Q-&gt;Front, Q); Q-&gt;Size--; return returnNum; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念船新SI单位——"陈俊鹏"的诞生]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[为什么是“陈俊鹏”？事情还得从2000年2月31日一个婴儿的出生说起…… 出生 2000年2月31日，在成都市的一处郊区，一个婴儿出生了。2月31日，那是10000000000000年都难得一遇的日子，由此可见，在这一天出生的那个婴儿，其身份也并不一般。原来，他是天上的火爆龙神，由于长得太过帅气，惹得天帝嫉妒，将其贬下凡间，投胎在一户富贵人家。那一天，风雨大作，紫气东来，连天上的云都连成了一个“帅”字。地球有史以来最帅的人————陈俊鹏，出生了。 成长 陈俊鹏出生在富贵人家，每天从两万平米的床上醒来，由四万个女仆照顾他的生活起居，吃的是天山万年雪莲，喝的是珠穆朗玛峰上的万年寒冰化成的水，他的颜值自然越来越高。到5岁时，就已经帅得天怒人怨。在18岁时，更是超过了当时的世界第一美男子————蔡徐鲲。每一个见到他的人，都被他那帅气的脸庞直接帅晕了过去。自此，世界各国都被这样一个帅气的人给惊动了。 创立新的SI单位 “帅”是一个抽象的概念，人们一直没法量化。直到陈俊鹏为世界所知，科学家们一致认为，可以用陈俊鹏作为单位，来量化“帅”这个概念，而恰好“俊”又是“帅”的意思，不得不说，陈俊鹏真实造物者赐给科学界的无上宝物。于是，继长度（米）、质量（千克）、时间（秒）、电流（安培）、热力学温度（开尔文）、物质的量（摩尔）和发光强度（坎德拉）之后，新的SI单位————颜值高度（陈俊鹏）诞生了。 简述“陈俊鹏”定义 1陈俊鹏被定义为在常温常压下，能见度一般（10到20公里）的情况下，能够使至少一个身体健康的（无特殊疾病）人因为你的颜值而激动至昏迷的颜值。简称俊，写作cjp。 使用 由于陈俊鹏是很大的单位，除了陈俊鹏本人以外没人能够达到，于是我们常常使用微陈俊鹏（μcjp），纳陈俊鹏（ncjp），皮陈俊鹏（pcjp）来表示颜值，一个正常人的颜值大约为5pcjp，能达到μcjp的人，就已经算帅得惊天地泣鬼神了。（注：蔡徐鲲的颜值为5μcjp） 附录最后附上几张陈俊鹏的帅照（请读者克制住自己犯罪的欲望）]]></content>
      <categories>
        <category>CJP</category>
      </categories>
      <tags>
        <tag>-SI -陈俊鹏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>1</category>
      </categories>
  </entry>
</search>
