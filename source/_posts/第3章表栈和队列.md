---
title: 第3章 表、栈和队列
date: 2019-07-25 15:46:50
tags: 
- 数据结构与算法
- 学习
categories: 数据结构与算法分析
---

## 表ADT

### 基本概念

​	空表（empty list）：大小为0的表。

​	前驱元、后继元。

### 链表

函数原型

```c
struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;

List MakeEmpty(List L);
int IsEmpty(List L);
int IsLast(Position P, List L);
Position Find(int X, List L);
void Insert(int X, List L, Position P);
void DeleteList(List L);
Position Header(List L);
```

具体实现：略

### 常见的错误

链表一般会出现指针变量包含了伪地址的问题。删除表时，需要一个中间量来储存上一个节点。同时，使用malloc之后记得将该节点初始化。

### 例子

#### 多项式ADT

令F(X) = ∑<sub>i=0</sub><sup>N</sup> A<sub>i</sub>X<sup>i</sup>。如果多项式的次数过大，使用普通方法的运行时间就难以接受了。于是可以采用多项式ADT来实现多项式的加减乘等操作。

多项式ADT的数组实现的类型声明

```c
typedef struct
{
    int CoeffArray[MaxDegree + 1];
    int HighPower;
} * Polynomial;
```

将多项式初始化为零的过程

```c
void ZeroPolynomial(Polynomial Poly)
{
    int i;
    
    for(i = 0; i <= MaxDegree; i++)
        Poly->CoeffArray[i] = 0;
    Poly->HighPower = 0;
}
```

两个多项式相加的过程

```c
void AddPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolySum)
{
    int i;
    ZeroPolynomial(PolySum);
    PolySum->HighPower = Max(Poly1->HighPower, Poly2->HighPower);
    for(i = PolySum->HighPower; i >= 0; i--)
        PolySum->CoeffArray[i] = Poly1->CoeffArray[i] + Poly2->CoeffArray[i];
}
```



两个多项式相乘的过程

```c
void MultPolynomial(const Plynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)
{
	int i, j;
	ZeroPolynomial(PolyProd);
	PolySum->HighPower = Poly1->HighPower + Poly2->HighPower;
	
	if(PolyProd->HighPower > MaxDegree)
		Error("Exceeded array size");
	else
        for(i = 0; i <= Poly1->HighPower; i++)
            for(j = 0; j <= Poly2->HighPower; j++)
                PolyProd->CoeffArray[i + j] += Poly1->CoeffArray[i] * Poly2->CoeffArray[j];
}
```

#### 基数排序

#### 多重表

***

## 栈ADT

### 栈模型

栈（stack）是限制插入和删除只能在一个位置上进行的表，该





